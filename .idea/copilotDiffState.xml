<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.saschl.sonygps&quot;&#10;    compileSdk = 36&#10;&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.15&quot;&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.saschl.sonygps&quot;&#10;        minSdk = 36&#10;        targetSdk = 36&#10;        versionCode = 10&#10;        versionName = &quot;1.2.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    signingConfigs {&#10;        create(&quot;release&quot;) {&#10;            keyAlias = System.getenv(&quot;SIGNING_KEY_ALIAS&quot;)&#10;            keyPassword = System.getenv(&quot;SIGNING_KEY_PASSWORD&quot;)&#10;            storeFile = file(&quot;keystore.jks&quot;)&#10;            storePassword = System.getenv(&quot;SIGNING_STORE_PASSWORD&quot;)&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;release&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.google.play.services.location)&#10;    implementation(libs.accompanist.permissions)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    implementation(libs.timber)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    id(&quot;kotlin-kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.saschl.sonygps&quot;&#10;    compileSdk = 36&#10;&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.15&quot;&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.saschl.sonygps&quot;&#10;        minSdk = 36&#10;        targetSdk = 36&#10;        versionCode = 10&#10;        versionName = &quot;1.2.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    signingConfigs {&#10;        create(&quot;release&quot;) {&#10;            keyAlias = System.getenv(&quot;SIGNING_KEY_ALIAS&quot;)&#10;            keyPassword = System.getenv(&quot;SIGNING_KEY_PASSWORD&quot;)&#10;            storeFile = file(&quot;keystore.jks&quot;)&#10;            storePassword = System.getenv(&quot;SIGNING_STORE_PASSWORD&quot;)&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;release&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.google.play.services.location)&#10;    implementation(libs.accompanist.permissions)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    implementation(libs.timber)&#10;    &#10;    // Room database dependencies&#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.room.ktx)&#10;    kapt(libs.androidx.room.compiler)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/MainActivity.kt" />
              <option name="originalContent" value="package com.saschl.sonygps&#10;&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.LinearLayout&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.saschl.sonygps.service.CompanionDeviceManagerSample&#10;import com.saschl.sonygps.service.FileTree&#10;import timber.log.Timber&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;&#10;    // needed to communicate with the service.&#10;&#10;    // we need notification permission to be able to display a notification for the foreground service&#10;    private val notificationPermissionLauncher =&#10;        registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) {&#10;            // if permission was denied, the service can still run only the notification won't be visible&#10;        }&#10;&#10;    // we need location permission to be able to start the service&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Only plant Timber once in the app lifecycle&#10;        if (Timber.treeCount == 0) {&#10;            FileTree.initialize(this)&#10;            Timber.plant(Timber.DebugTree(), FileTree(this))&#10;        }&#10;&#10;        Timber.i(&quot;onCreate called&quot;)&#10;        val layout = LinearLayout(this)&#10;        layout.orientation = LinearLayout.VERTICAL&#10;        layout.setPadding(16, 16, 16, 16)&#10;&#10;        val logButton = Button(this).apply {&#10;            text = &quot;View Logs&quot;&#10;            setOnClickListener {&#10;                startActivity(Intent(this@MainActivity, com.saschl.sonygps.ui.LogViewerActivity::class.java))&#10;            }&#10;        }&#10;        layout.addView(logButton)&#10;        val composeView = androidx.compose.ui.platform.ComposeView(this).apply {&#10;            setContent { CompanionDeviceManagerSample() }&#10;        }&#10;        layout.addView(composeView)&#10;        setContentView(layout)&#10;&#10;        // Handle system bars to prevent button from appearing in status bar&#10;        ViewCompat.setOnApplyWindowInsetsListener(layout) { view, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            view.setPadding(16, systemBars.top + 16, 16, systemBars.bottom + 16)&#10;            insets&#10;        }&#10;&#10;        checkAndRequestNotificationPermission()&#10;    }&#10;&#10;&#10;    /**&#10;     * Check for notification permission before starting the service so that the notification is visible&#10;     */&#10;    private fun checkAndRequestNotificationPermission() {&#10;        when (ContextCompat.checkSelfPermission(&#10;            this,&#10;            android.Manifest.permission.POST_NOTIFICATIONS&#10;        )) {&#10;            android.content.pm.PackageManager.PERMISSION_GRANTED -&gt; {&#10;                // permission already granted&#10;            }&#10;&#10;            else -&gt; {&#10;                notificationPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MainActivity&quot;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.saschl.sonygps&#10;&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.LinearLayout&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.saschl.sonygps.service.CompanionDeviceManagerSample&#10;import com.saschl.sonygps.service.FileTree&#10;import com.saschl.sonygps.service.GlobalExceptionHandler&#10;import timber.log.Timber&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;&#10;    // needed to communicate with the service.&#10;&#10;    // we need notification permission to be able to display a notification for the foreground service&#10;    private val notificationPermissionLauncher =&#10;        registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) {&#10;            // if permission was denied, the service can still run only the notification won't be visible&#10;        }&#10;&#10;    // we need location permission to be able to start the service&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Only plant Timber once in the app lifecycle&#10;        if (Timber.treeCount == 0) {&#10;            FileTree.initialize(this)&#10;            Timber.plant(Timber.DebugTree(), FileTree(this))&#10;&#10;            // Set up global exception handler to log crashes&#10;            val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()&#10;            Thread.setDefaultUncaughtExceptionHandler(GlobalExceptionHandler(defaultHandler))&#10;        }&#10;&#10;        Timber.i(&quot;onCreate called&quot;)&#10;        val layout = LinearLayout(this)&#10;        layout.orientation = LinearLayout.VERTICAL&#10;        layout.setPadding(16, 16, 16, 16)&#10;&#10;        val logButton = Button(this).apply {&#10;            text = &quot;View Logs&quot;&#10;            setOnClickListener {&#10;                startActivity(Intent(this@MainActivity, com.saschl.sonygps.ui.LogViewerActivity::class.java))&#10;            }&#10;        }&#10;        layout.addView(logButton)&#10;        val composeView = androidx.compose.ui.platform.ComposeView(this).apply {&#10;            setContent { CompanionDeviceManagerSample() }&#10;        }&#10;        layout.addView(composeView)&#10;        setContentView(layout)&#10;&#10;        // Handle system bars to prevent button from appearing in status bar&#10;        ViewCompat.setOnApplyWindowInsetsListener(layout) { view, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            view.setPadding(16, systemBars.top + 16, 16, systemBars.bottom + 16)&#10;            insets&#10;        }&#10;&#10;        checkAndRequestNotificationPermission()&#10;    }&#10;&#10;&#10;    /**&#10;     * Check for notification permission before starting the service so that the notification is visible&#10;     */&#10;    private fun checkAndRequestNotificationPermission() {&#10;        when (ContextCompat.checkSelfPermission(&#10;            this,&#10;            android.Manifest.permission.POST_NOTIFICATIONS&#10;        )) {&#10;            android.content.pm.PackageManager.PERMISSION_GRANTED -&gt; {&#10;                // permission already granted&#10;            }&#10;&#10;            else -&gt; {&#10;                notificationPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MainActivity&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDao.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.Query&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface LogDao {&#10;    @Insert&#10;    suspend fun insertLog(logEntry: LogEntry)&#10;&#10;    @Query(&quot;SELECT * FROM log_entries ORDER BY timestamp DESC&quot;)&#10;    fun getAllLogs(): Flow&lt;List&lt;LogEntry&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM log_entries ORDER BY timestamp DESC LIMIT :limit&quot;)&#10;    suspend fun getRecentLogs(limit: Int = 200): List&lt;LogEntry&gt;&#10;&#10;    @Query(&quot;DELETE FROM log_entries WHERE id NOT IN (SELECT id FROM log_entries ORDER BY timestamp DESC LIMIT :keepCount)&quot;)&#10;    suspend fun deleteOldLogs(keepCount: Int = 500)&#10;&#10;    @Query(&quot;DELETE FROM log_entries&quot;)&#10;    suspend fun clearAllLogs()&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM log_entries&quot;)&#10;    suspend fun getLogCount(): Int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDatabase.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [LogEntry::class],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;abstract class LogDatabase : RoomDatabase() {&#10;    abstract fun logDao(): LogDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: LogDatabase? = null&#10;&#10;        fun getDatabase(context: Context): LogDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    LogDatabase::class.java,&#10;                    &quot;log_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogEntry.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogEntry.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;log_entries&quot;)&#10;data class LogEntry(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;    val timestamp: Long,&#10;    val priority: Int,&#10;    val tag: String?,&#10;    val message: String,&#10;    val exception: String?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogRepository.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.launch&#10;&#10;class LogRepository(context: Context) {&#10;    private val logDao = LogDatabase.getDatabase(context).logDao()&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    fun insertLog(timestamp: Long, priority: Int, tag: String?, message: String, exception: String?) {&#10;        scope.launch {&#10;            val logEntry = LogEntry(&#10;                timestamp = timestamp,&#10;                priority = priority,&#10;                tag = tag,&#10;                message = message,&#10;                exception = exception&#10;            )&#10;            logDao.insertLog(logEntry)&#10;            &#10;            // Clean up old logs to prevent database from growing too large&#10;            val count = logDao.getLogCount()&#10;            if (count &gt; 1000) {&#10;                logDao.deleteOldLogs(500) // Keep only latest 500 logs&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getAllLogs(): Flow&lt;List&lt;LogEntry&gt;&gt; = logDao.getAllLogs()&#10;&#10;    suspend fun getRecentLogs(limit: Int = 200): List&lt;LogEntry&gt; = logDao.getRecentLogs(limit)&#10;&#10;    fun clearAllLogs() {&#10;        scope.launch {&#10;            logDao.clearAllLogs()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/CompanionDeviceSampleService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/CompanionDeviceSampleService.kt" />
              <option name="originalContent" value="/*&#10; * Copyright 2023 The Android Open Source Project&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10; * you may not use this file except in compliance with the License.&#10; * You may obtain a copy of the License at&#10; *&#10; *     https://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10; * See the License for the specific language governing permissions and&#10; * limitations under the License.&#10; */&#10;&#10;package com.saschl.sonygps.service&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.NotificationManager&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothManager&#10;import android.bluetooth.BluetoothProfile&#10;import android.companion.AssociationInfo&#10;import android.companion.CompanionDeviceManager&#10;import android.companion.CompanionDeviceService&#10;import android.companion.DevicePresenceEvent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.app.NotificationChannelCompat&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import androidx.core.content.getSystemService&#10;import androidx.core.graphics.drawable.IconCompat&#10;import com.google.android.gms.tasks.CancellationTokenSource&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import timber.log.Timber&#10;import java.util.Locale&#10;import java.util.TimeZone&#10;import java.util.UUID&#10;&#10;&#10;class CompanionDeviceSampleService : CompanionDeviceService() {&#10;&#10;    // private lateinit var mHandler: Handler&#10;    /*  private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;      private lateinit var locationCallback: LocationCallback*/&#10;    // private var gatt1: BluetoothGatt? = null&#10;&#10;    private var characteristic: BluetoothGattCharacteristic? = null&#10;&#10;    private var locationResultVar: Location = Location(&quot;&quot;)&#10;&#10;    //private val coroutineScope = CoroutineScope(Job())&#10;    // private lateinit var timerJob: Timer&#10;&#10;    private var cancellationToken = CancellationTokenSource()&#10;&#10;&#10;    companion object {&#10;&#10;        // Random UUID for our service known between the client and server to allow communication&#10;        val SERVICE_UUID: UUID = UUID.fromString(&quot;8000dd00-dd00-ffff-ffff-ffffffffffff&quot;)&#10;&#10;        // Same as the service but for the characteristic&#10;        val CHARACTERISTIC_UUID: UUID = UUID.fromString(&quot;0000dd11-0000-1000-8000-00805f9b34fb&quot;)&#10;&#10;        private const val CHANNEL = &quot;gatt_server_channel&quot;&#10;    }&#10;&#10;&#10;    private val notificationManager: DeviceNotificationManager by lazy {&#10;        DeviceNotificationManager(applicationContext)&#10;    }&#10;&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onDevicePresenceEvent(event: DevicePresenceEvent) {&#10;        super.onDevicePresenceEvent(event)&#10;        if (missingPermissions()) {&#10;            Log.e(CompanionDeviceSampleService::class.java.toString(), &quot;aaa&quot;);&#10;            return&#10;        }&#10;&#10;        if (event.event == DevicePresenceEvent.EVENT_BLE_APPEARED) {&#10;&#10;            val associationId = event.getAssociationId()&#10;            val deviceManager = getSystemService&lt;CompanionDeviceManager&gt;()&#10;            val associatedDevices = deviceManager?.getMyAssociations()&#10;            val associationInfo = associatedDevices?.find { it.id == associationId }&#10;            val address = associationInfo?.deviceMacAddress?.toString()&#10;            /*  var device: BluetoothDevice? = null&#10;            if (Build.VERSION.SDK_INT &gt;= 34) {&#10;                device = associationInfo.associatedDevice?.bleDevice?.device&#10;            }&#10;            if (device == null) {&#10;                device = bluetoothManager.adapter.getRemoteDevice(address)&#10;            }*/&#10;&#10;            val serviceIntent = Intent(this, LocationSenderService::class.java)&#10;            serviceIntent.putExtra(&quot;address&quot;, address?.uppercase(Locale.getDefault()))&#10;            Timber.i(&quot;WILL STRART THE FOREGROUND BITCH&quot;)&#10;            notificationManager.onDeviceAppeared(&quot;nah&quot;, &quot;HERE I AM&quot;)&#10;            startForegroundService(serviceIntent)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        //   fusedLocationClient.removeLocationUpdates(locationCallback)&#10;        // timerJob.cancel()&#10;&#10;        //fusedLocationClient.removeLocationUpdates(locationCallback)&#10;&#10;        stopService(Intent(this, LocationSenderService::class.java))&#10;        notificationManager.onDeviceDisappeared(&quot;Service gone :)&quot;)&#10;&#10;        /*   gatt?.disconnect()&#10;           gatt?.close()*/&#10;        Log.e(&quot;service&quot;, &quot;Destroyed service&quot;)&#10;    }&#10;&#10;    /*  override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;          super.onStartCommand(intent, flags, startId)&#10;&#10;          return START_STICKY&#10;      }*/&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;&#10;      /*  Timber.plant(&#10;            Timber.DebugTree(),&#10;            FileTree()&#10;        )*/&#10;&#10;    }&#10;&#10;    /**&#10;     * Check BLUETOOTH_CONNECT is granted and POST_NOTIFICATIONS is granted for devices running&#10;     * Android 13 and above.&#10;     */&#10;    private fun missingPermissions(): Boolean = ActivityCompat.checkSelfPermission(&#10;        this,&#10;        Manifest.permission.BLUETOOTH_CONNECT,&#10;    ) != PackageManager.PERMISSION_GRANTED ||&#10;            ActivityCompat.checkSelfPermission(&#10;                this,&#10;                Manifest.permission.POST_NOTIFICATIONS,&#10;            ) != PackageManager.PERMISSION_GRANTED&#10;&#10;    /**&#10;     * Utility class to post notification when CDM notifies that a device appears or disappears&#10;     */&#10;    class DeviceNotificationManager(context: Context) {&#10;&#10;        companion object {&#10;            private const val CDM_CHANNEL = &quot;cdm_channel&quot;&#10;        }&#10;&#10;        private val manager = NotificationManagerCompat.from(context)&#10;&#10;        private val notificationBuilder = NotificationCompat.Builder(context, CDM_CHANNEL)&#10;            .setSmallIcon(IconCompat.createWithResource(context, context.applicationInfo.icon))&#10;            .setContentTitle(&quot;Companion Device Manager Sample&quot;)&#10;&#10;        init {&#10;            createNotificationChannel()&#10;        }&#10;&#10;        @RequiresPermission(Manifest.permission.POST_NOTIFICATIONS)&#10;        fun onDeviceAppeared(address: String, status: String) {&#10;            val notification =&#10;                notificationBuilder.setContentText(&quot;Device: $address appeared.\nStatus: $status&quot;)&#10;            manager.notify(address.hashCode(), notification.build())&#10;        }&#10;&#10;        @RequiresPermission(Manifest.permission.POST_NOTIFICATIONS)&#10;        fun onDeviceDisappeared(address: String) {&#10;            val notification = notificationBuilder.setContentText(&quot;Device: $address disappeared&quot;)&#10;            manager.notify(address.hashCode(), notification.build())&#10;        }&#10;&#10;        private fun createNotificationChannel() {&#10;            val channel =&#10;                NotificationChannelCompat.Builder(CDM_CHANNEL, NotificationManager.IMPORTANCE_HIGH)&#10;                    .setName(&quot;CDM Sample&quot;)&#10;                    .setDescription(&quot;Channel for the CDM sample&quot;)&#10;                    .build()&#10;            manager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;}&#10;&#10;   /* @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun sendData(&#10;        gatt: BluetoothGatt?,&#10;        characteristic: BluetoothGattCharacteristic?,&#10;    ) {&#10;        val data = ByteArray(95)&#10;&#10;        data[0] = 0x00&#10;        data[1] = 0x5D.toByte()&#10;&#10;&#10;        // bytes 2-4&#10;        val fixedData = &quot;0802FC&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;        System.arraycopy(fixedData, 0, data, 2, fixedData.size)&#10;&#10;        // transmit timezone offset? NO&#10;        data[5] = 0x00.toByte()&#10;&#10;        val fixedData2 = &quot;0000101010&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;&#10;        System.arraycopy(fixedData2, 0, data, 6, fixedData2.size)&#10;        // position information&#10;        //  Log.e(&quot;thisThing&quot;, locationResultVar!!.latitude.toString());&#10;        val latitude = locationResultVar.latitude&#10;        val longitude = locationResultVar.longitude&#10;        val locationData = set_location(latitude, longitude)&#10;        System.arraycopy(locationData, 0, data, 11, locationData.size)&#10;&#10;&#10;        // here UTC time must be used&#10;        val dateData = set_date(TimeZone.getTimeZone(&quot;UTC&quot;).toZoneId())&#10;        System.arraycopy(dateData, 0, data, 19, dateData.size)&#10;        // Set the last offsets&#10;        // timezone offset&#10;        *//*    val calendar = Calendar.getInstance(timezone)&#10;            val offsetMin = calendar.get(Calendar.ZONE_OFFSET) / 60000&#10;            val offsetMinBytes = ByteBuffer.allocate(2).putShort(offsetMin.toShort()).array()&#10;    *//*&#10;        // dst offset&#10;        *//* val offsetDstMin = calendar.get(Calendar.DST_OFFSET) / 60000&#10;         val offsetDstMinBytes = ByteBuffer.allocate(2).putShort(offsetDstMin.toShort()).array()*//*&#10;&#10;&#10;        // TODO does weird stuff, probably not needed as camera has TZ configured&#10;        *//*   data[91] = offsetMinBytes[0]&#10;           data[92] = offsetMinBytes[1]&#10;           data[93] = offsetDstMinBytes[0]&#10;           data[94] = offsetDstMinBytes[1]*//*&#10;&#10;        val hex = data.toHex()&#10;        Log.i(&quot;ayup&quot;, &quot;Sending data: $hex with location $locationResultVar&quot;)&#10;&#10;        if (characteristic != null) {&#10;            val result = gatt?.writeCharacteristic(&#10;                characteristic,&#10;                data,&#10;                BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT,&#10;            )&#10;            Log.i(&quot;ayup&quot;, &quot;Write result: $result&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;&#10;fun ByteArray.toHex(): String = joinToString(separator = &quot;&quot;) { eachByte -&gt; &quot;%02x&quot;.format(eachByte) }*/&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="/*&#10; * Copyright 2023 The Android Open Source Project&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10; * you may not use this file except in compliance with the License.&#10; * You may obtain a copy of the License at&#10; *&#10; *     https://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10; * See the License for the specific language governing permissions and&#10; * limitations under the License.&#10; */&#10;&#10;package com.saschl.sonygps.service&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.NotificationManager&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothManager&#10;import android.bluetooth.BluetoothProfile&#10;import android.companion.AssociationInfo&#10;import android.companion.CompanionDeviceManager&#10;import android.companion.CompanionDeviceService&#10;import android.companion.DevicePresenceEvent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import android.os.Build&#10;import androidx.annotation.RequiresPermission&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.app.NotificationChannelCompat&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import androidx.core.content.getSystemService&#10;import androidx.core.graphics.drawable.IconCompat&#10;import com.google.android.gms.tasks.CancellationTokenSource&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import timber.log.Timber&#10;import java.util.Locale&#10;import java.util.TimeZone&#10;import java.util.UUID&#10;&#10;&#10;class CompanionDeviceSampleService : CompanionDeviceService() {&#10;&#10;    // private lateinit var mHandler: Handler&#10;    /*  private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;      private lateinit var locationCallback: LocationCallback*/&#10;    // private var gatt1: BluetoothGatt? = null&#10;&#10;    private var characteristic: BluetoothGattCharacteristic? = null&#10;&#10;    private var locationResultVar: Location = Location(&quot;&quot;)&#10;&#10;    //private val coroutineScope = CoroutineScope(Job())&#10;    // private lateinit var timerJob: Timer&#10;&#10;    private var cancellationToken = CancellationTokenSource()&#10;&#10;&#10;    companion object {&#10;&#10;        // Random UUID for our service known between the client and server to allow communication&#10;        val SERVICE_UUID: UUID = UUID.fromString(&quot;8000dd00-dd00-ffff-ffff-ffffffffffff&quot;)&#10;&#10;        // Same as the service but for the characteristic&#10;        val CHARACTERISTIC_UUID: UUID = UUID.fromString(&quot;0000dd11-0000-1000-8000-00805f9b34fb&quot;)&#10;&#10;        private const val CHANNEL = &quot;gatt_server_channel&quot;&#10;    }&#10;&#10;&#10;    private val notificationManager: DeviceNotificationManager by lazy {&#10;        DeviceNotificationManager(applicationContext)&#10;    }&#10;&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onDevicePresenceEvent(event: DevicePresenceEvent) {&#10;        super.onDevicePresenceEvent(event)&#10;        if (missingPermissions()) {&#10;            Timber.e(CompanionDeviceSampleService::class.java.toString(), &quot;Missing permissions&quot;)&#10;            return&#10;        }&#10;&#10;        if (event.event == DevicePresenceEvent.EVENT_BLE_APPEARED) {&#10;&#10;            val associationId = event.getAssociationId()&#10;            val deviceManager = getSystemService&lt;CompanionDeviceManager&gt;()&#10;            val associatedDevices = deviceManager?.getMyAssociations()&#10;            val associationInfo = associatedDevices?.find { it.id == associationId }&#10;            val address = associationInfo?.deviceMacAddress?.toString()&#10;            /*  var device: BluetoothDevice? = null&#10;            if (Build.VERSION.SDK_INT &gt;= 34) {&#10;                device = associationInfo.associatedDevice?.bleDevice?.device&#10;            }&#10;            if (device == null) {&#10;                device = bluetoothManager.adapter.getRemoteDevice(address)&#10;            }*/&#10;&#10;            val serviceIntent = Intent(this, LocationSenderService::class.java)&#10;            serviceIntent.putExtra(&quot;address&quot;, address?.uppercase(Locale.getDefault()))&#10;            Timber.i(&quot;WILL STRART THE FOREGROUND BITCH&quot;)&#10;            notificationManager.onDeviceAppeared(&quot;nah&quot;, &quot;HERE I AM&quot;)&#10;            startForegroundService(serviceIntent)&#10;        }&#10;    }&#10;&#10;&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        //   fusedLocationClient.removeLocationUpdates(locationCallback)&#10;        // timerJob.cancel()&#10;&#10;        //fusedLocationClient.removeLocationUpdates(locationCallback)&#10;&#10;        stopService(Intent(this, LocationSenderService::class.java))&#10;        notificationManager.onDeviceDisappeared(&quot;Service gone :)&quot;)&#10;&#10;        /*   gatt?.disconnect()&#10;           gatt?.close()*/&#10;        Timber.e(&quot;service&quot;, &quot;Destroyed service&quot;)&#10;    }&#10;&#10;    /*  override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;          super.onStartCommand(intent, flags, startId)&#10;&#10;          return START_STICKY&#10;      }*/&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;&#10;      /*  Timber.plant(&#10;            Timber.DebugTree(),&#10;            FileTree()&#10;        )*/&#10;&#10;    }&#10;&#10;    /**&#10;     * Check BLUETOOTH_CONNECT is granted and POST_NOTIFICATIONS is granted for devices running&#10;     * Android 13 and above.&#10;     */&#10;    private fun missingPermissions(): Boolean = ActivityCompat.checkSelfPermission(&#10;        this,&#10;        Manifest.permission.BLUETOOTH_CONNECT,&#10;    ) != PackageManager.PERMISSION_GRANTED ||&#10;            ActivityCompat.checkSelfPermission(&#10;                this,&#10;                Manifest.permission.POST_NOTIFICATIONS,&#10;            ) != PackageManager.PERMISSION_GRANTED&#10;&#10;    /**&#10;     * Utility class to post notification when CDM notifies that a device appears or disappears&#10;     */&#10;    class DeviceNotificationManager(context: Context) {&#10;&#10;        companion object {&#10;            private const val CDM_CHANNEL = &quot;cdm_channel&quot;&#10;        }&#10;&#10;        private val manager = NotificationManagerCompat.from(context)&#10;&#10;        private val notificationBuilder = NotificationCompat.Builder(context, CDM_CHANNEL)&#10;            .setSmallIcon(IconCompat.createWithResource(context, context.applicationInfo.icon))&#10;            .setContentTitle(&quot;Companion Device Manager Sample&quot;)&#10;&#10;        init {&#10;            createNotificationChannel()&#10;        }&#10;&#10;        @RequiresPermission(Manifest.permission.POST_NOTIFICATIONS)&#10;        fun onDeviceAppeared(address: String, status: String) {&#10;            val notification =&#10;                notificationBuilder.setContentText(&quot;Device: $address appeared.\nStatus: $status&quot;)&#10;            manager.notify(address.hashCode(), notification.build())&#10;        }&#10;&#10;        @RequiresPermission(Manifest.permission.POST_NOTIFICATIONS)&#10;        fun onDeviceDisappeared(address: String) {&#10;            val notification = notificationBuilder.setContentText(&quot;Device: $address disappeared&quot;)&#10;            manager.notify(address.hashCode(), notification.build())&#10;        }&#10;&#10;        private fun createNotificationChannel() {&#10;            val channel =&#10;                NotificationChannelCompat.Builder(CDM_CHANNEL, NotificationManager.IMPORTANCE_HIGH)&#10;                    .setName(&quot;CDM Sample&quot;)&#10;                    .setDescription(&quot;Channel for the CDM sample&quot;)&#10;                    .build()&#10;            manager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;}&#10;&#10;   /* @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun sendData(&#10;        gatt: BluetoothGatt?,&#10;        characteristic: BluetoothGattCharacteristic?,&#10;    ) {&#10;        val data = ByteArray(95)&#10;&#10;        data[0] = 0x00&#10;        data[1] = 0x5D.toByte()&#10;&#10;&#10;        // bytes 2-4&#10;        val fixedData = &quot;0802FC&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;        System.arraycopy(fixedData, 0, data, 2, fixedData.size)&#10;&#10;        // transmit timezone offset? NO&#10;        data[5] = 0x00.toByte()&#10;&#10;        val fixedData2 = &quot;0000101010&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;&#10;        System.arraycopy(fixedData2, 0, data, 6, fixedData2.size)&#10;        // position information&#10;        //  Log.e(&quot;thisThing&quot;, locationResultVar!!.latitude.toString());&#10;        val latitude = locationResultVar.latitude&#10;        val longitude = locationResultVar.longitude&#10;        val locationData = set_location(latitude, longitude)&#10;        System.arraycopy(locationData, 0, data, 11, locationData.size)&#10;&#10;&#10;        // here UTC time must be used&#10;        val dateData = set_date(TimeZone.getTimeZone(&quot;UTC&quot;).toZoneId())&#10;        System.arraycopy(dateData, 0, data, 19, dateData.size)&#10;        // Set the last offsets&#10;        // timezone offset&#10;        *//*    val calendar = Calendar.getInstance(timezone)&#10;            val offsetMin = calendar.get(Calendar.ZONE_OFFSET) / 60000&#10;            val offsetMinBytes = ByteBuffer.allocate(2).putShort(offsetMin.toShort()).array()&#10;    *//*&#10;        // dst offset&#10;        *//* val offsetDstMin = calendar.get(Calendar.DST_OFFSET) / 60000&#10;         val offsetDstMinBytes = ByteBuffer.allocate(2).putShort(offsetDstMin.toShort()).array()*//*&#10;&#10;&#10;        // TODO does weird stuff, probably not needed as camera has TZ configured&#10;        *//*   data[91] = offsetMinBytes[0]&#10;           data[92] = offsetMinBytes[1]&#10;           data[93] = offsetDstMinBytes[0]&#10;           data[94] = offsetDstMinBytes[1]*/*&#10;&#10;        val hex = data.toHex()&#10;        Timber.i(&quot;ayup&quot;, &quot;Sending data: $hex with location $locationResultVar&quot;)&#10;&#10;        if (characteristic != null) {&#10;            val result = gatt?.writeCharacteristic(&#10;                characteristic,&#10;                data,&#10;                BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT,&#10;            )&#10;            Timber.i(&quot;ayup&quot;, &quot;Write result: $result&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;&#10;fun ByteArray.toHex(): String = joinToString(separator = &quot;&quot;) { eachByte -&gt; &quot;%02x&quot;.format(eachByte) }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/FileTree.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/FileTree.kt" />
              <option name="originalContent" value="package com.saschl.sonygps.service&#10;&#10;import android.content.Context&#10;import timber.log.Timber&#10;import com.saschl.sonygps.database.LogRepository&#10;import kotlinx.coroutines.runBlocking&#10;&#10;class FileTree(context: Context) : Timber.Tree() {&#10;    private val logRepository = LogRepository(context.applicationContext)&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var logRepository: LogRepository? = null&#10;&#10;        fun initialize(context: Context) {&#10;            if (logRepository == null) {&#10;                synchronized(this) {&#10;                    if (logRepository == null) {&#10;                        logRepository = LogRepository(context.applicationContext)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        fun getLogs(): List&lt;String&gt; {&#10;            return logRepository?.let { repo -&gt;&#10;                runBlocking {&#10;                    repo.getRecentLogs().map { logEntry -&gt;&#10;                        &quot;[${priorityToString(logEntry.priority)}] ${logEntry.tag ?: &quot;App&quot;}: ${logEntry.message}&quot; +&#10;                                (logEntry.exception?.let { &quot;\n$it&quot; } ?: &quot;&quot;)&#10;                    }&#10;                }&#10;            } ?: emptyList()&#10;        }&#10;&#10;        fun clearLogs() {&#10;            logRepository?.clearAllLogs()&#10;        }&#10;&#10;        private fun priorityToString(priority: Int): String = when (priority) {&#10;            android.util.Log.VERBOSE -&gt; &quot;V&quot;&#10;            android.util.Log.DEBUG -&gt; &quot;D&quot;&#10;            android.util.Log.INFO -&gt; &quot;I&quot;&#10;            android.util.Log.WARN -&gt; &quot;W&quot;&#10;            android.util.Log.ERROR -&gt; &quot;E&quot;&#10;            android.util.Log.ASSERT -&gt; &quot;A&quot;&#10;            else -&gt; priority.toString()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Write a log message to its destination. Called for all level-specific methods by default.&#10;     *&#10;     * @param priority Log level. See [Log] for constants.&#10;     * @param tag Explicit or inferred tag. May be `null`.&#10;     * @param message Formatted log message. May be `null`, but then `t` will not be.&#10;     * @param t Accompanying exceptions. May be `null`, but then `message` will not be.&#10;     */&#10;    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {&#10;        val timestamp = System.currentTimeMillis()&#10;        val exception = t?.stackTraceToString()&#10;&#10;        logRepository.insertLog(timestamp, priority, tag, message, exception)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.saschl.sonygps.service&#10;&#10;import android.content.Context&#10;import timber.log.Timber&#10;import com.saschl.sonygps.database.LogRepository&#10;import kotlinx.coroutines.runBlocking&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;class FileTree(context: Context) : Timber.Tree() {&#10;    private val logRepository = LogRepository(context.applicationContext)&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var logRepository: LogRepository? = null&#10;        private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;, Locale.getDefault())&#10;&#10;        fun initialize(context: Context) {&#10;            if (logRepository == null) {&#10;                synchronized(this) {&#10;                    if (logRepository == null) {&#10;                        logRepository = LogRepository(context.applicationContext)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        fun getLogs(): List&lt;String&gt; {&#10;            return logRepository?.let { repo -&gt;&#10;                runBlocking {&#10;                    repo.getRecentLogs().map { logEntry -&gt;&#10;                        val date = dateFormat.format(Date(logEntry.timestamp))&#10;                        &quot;[$date] [${priorityToString(logEntry.priority)}] ${logEntry.tag ?: &quot;App&quot;}: ${logEntry.message}&quot; +&#10;                                (logEntry.exception?.let { &quot;\n$it&quot; } ?: &quot;&quot;)&#10;                    }&#10;                }&#10;            } ?: emptyList()&#10;        }&#10;&#10;        fun clearLogs() {&#10;            logRepository?.clearAllLogs()&#10;        }&#10;&#10;        private fun priorityToString(priority: Int): String = when (priority) {&#10;            android.util.Log.VERBOSE -&gt; &quot;V&quot;&#10;            android.util.Log.DEBUG -&gt; &quot;D&quot;&#10;            android.util.Log.INFO -&gt; &quot;I&quot;&#10;            android.util.Log.WARN -&gt; &quot;W&quot;&#10;            android.util.Log.ERROR -&gt; &quot;E&quot;&#10;            android.util.Log.ASSERT -&gt; &quot;A&quot;&#10;            else -&gt; priority.toString()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Write a log message to its destination. Called for all level-specific methods by default.&#10;     *&#10;     * @param priority Log level. See [Log] for constants.&#10;     * @param tag Explicit or inferred tag. May be `null`.&#10;     * @param message Formatted log message. May be `null`, but then `t` will not be.&#10;     * @param t Accompanying exceptions. May be `null`, but then `message` will not be.&#10;     */&#10;    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {&#10;        val timestamp = System.currentTimeMillis()&#10;        val exception = t?.stackTraceToString()&#10;&#10;        logRepository.insertLog(timestamp, priority, tag, message, exception)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/GlobalExceptionHandler.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/GlobalExceptionHandler.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.service&#10;&#10;import timber.log.Timber&#10;&#10;class CrashReportingTree : Timber.Tree() {&#10;    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {&#10;        // Only log errors and warnings to avoid spam&#10;        if (priority == android.util.Log.ERROR || priority == android.util.Log.WARN) {&#10;            // You could also send to crashlytics or other crash reporting service here&#10;            super.log(priority, tag, message, t)&#10;        }&#10;    }&#10;}&#10;&#10;class GlobalExceptionHandler(&#10;    private val defaultHandler: Thread.UncaughtExceptionHandler?&#10;) : Thread.UncaughtExceptionHandler {&#10;&#10;    override fun uncaughtException(thread: Thread, exception: Throwable) {&#10;        try {&#10;            // Log the uncaught exception with Timber&#10;            Timber.e(exception, &quot;Uncaught exception in thread ${thread.name}&quot;)&#10;            &#10;            // Also log some additional context&#10;            Timber.e(&quot;CRASH&quot;, &quot;Thread: ${thread.name}, ID: ${thread.id}&quot;)&#10;            Timber.e(&quot;CRASH&quot;, &quot;Exception: ${exception.javaClass.simpleName}&quot;)&#10;            Timber.e(&quot;CRASH&quot;, &quot;Message: ${exception.message}&quot;)&#10;            Timber.e(&quot;CRASH&quot;, &quot;Stack trace: ${exception.stackTraceToString()}&quot;)&#10;            &#10;        } catch (e: Exception) {&#10;            // If logging fails for some reason, we don't want to cause another crash&#10;            e.printStackTrace()&#10;        } finally {&#10;            // Call the default handler to let the system handle the crash normally&#10;            defaultHandler?.uncaughtException(thread, exception)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/LocationSenderService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/LocationSenderService.kt" />
              <option name="originalContent" value="package com.saschl.sonygps.service&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.Service&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothManager&#10;import android.content.Intent&#10;import android.content.pm.ServiceInfo&#10;import android.location.Location&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import androidx.core.app.ServiceCompat&#10;import androidx.core.content.getSystemService&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.Priority&#10;import com.saschl.sonygps.notification.NotificationsHelper&#10;import com.saschl.sonygps.service.CompanionDeviceSampleService.DeviceNotificationManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import java.util.TimeZone&#10;import java.util.Timer&#10;import java.util.TimerTask&#10;import java.util.UUID&#10;&#10;class LocationSenderService : Service() {&#10;&#10;    private var startId: Int = 0&#10;    private val binder = LocalBinder()&#10;&#10;    private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;    private lateinit var locationCallback: LocationCallback&#10;    private var gatt1: BluetoothGatt? = null&#10;&#10;    private var characteristic: BluetoothGattCharacteristic? = null&#10;&#10;    private var locationResultVar: Location = Location(&quot;&quot;)&#10;&#10;    private var shutdownTimer = Timer()&#10;&#10;    companion object {&#10;&#10;        // Random UUID for our service known between the client and server to allow communication&#10;        val SERVICE_UUID: UUID = UUID.fromString(&quot;8000dd00-dd00-ffff-ffff-ffffffffffff&quot;)&#10;&#10;        // Same as the service but for the characteristic&#10;        val CHARACTERISTIC_UUID: UUID = UUID.fromString(&quot;0000dd11-0000-1000-8000-00805f9b34fb&quot;)&#10;&#10;&#10;        // Important: this is just for simplicity, there are better ways to communicate between&#10;        // a service and an activity/view&#10;        val serverLogsState: MutableStateFlow&lt;String&gt; = MutableStateFlow(&quot;&quot;)&#10;        val isServerRunning = MutableStateFlow(false)&#10;&#10;        private const val CHANNEL = &quot;gatt_server_channel&quot;&#10;    }&#10;&#10;    private val notificationManager: DeviceNotificationManager by lazy {&#10;        DeviceNotificationManager(applicationContext)&#10;    }&#10;&#10;    private val bluetoothManager: BluetoothManager by lazy {&#10;        applicationContext.getSystemService()!!&#10;    }&#10;&#10;&#10;    inner class LocalBinder : Binder() {&#10;        fun getService(): LocationSenderService = this@LocationSenderService&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder {&#10;        return binder&#10;    }&#10;&#10;    private val callback = object : BluetoothGattCallback() {&#10;        @SuppressLint(&quot;MissingPermission&quot;)&#10;        override fun onConnectionStateChange(&#10;            gatt: BluetoothGatt,&#10;            status: Int,&#10;            newState: Int,&#10;        ) {&#10;            super.onConnectionStateChange(gatt, status, newState)&#10;&#10;            // state = state.copy(gatt = gatt, connectionState = newState)&#10;            //  currentOnStateChange(state)&#10;&#10;            if (status != BluetoothGatt.GATT_SUCCESS) {&#10;                // Here you should handle the error returned in status based on the constants&#10;                // https://developer.android.com/reference/android/bluetooth/BluetoothGatt#summary&#10;                // For example for GATT_INSUFFICIENT_ENCRYPTION or&#10;                // GATT_INSUFFICIENT_AUTHENTICATION you should create a bond.&#10;                // https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createBond()&#10;&#10;                Log.e(&quot;BLEConnectEffect&quot;, &quot;An error happened: $status&quot;)&#10;                fusedLocationClient.removeLocationUpdates(locationCallback)&#10;                shutdownTimer = Timer()&#10;               /* shutdownTimer.schedule(object : TimerTask() {&#10;                    override fun run() {&#10;&#10;                        Log.e(&quot;LocationSenderService&quot;, &quot;Disconnecting and closing&quot;)&#10;                        gatt.disconnect()&#10;                        gatt.close()&#10;                        stopSelf(startId)&#10;                    }&#10;&#10;                }, 120000)*/&#10;            } else {&#10;                shutdownTimer.cancel()&#10;                shutdownTimer.purge()&#10;&#10;                Log.i(&quot;BLEConnectEffect&quot;, &quot;Connected to device&quot;)&#10;                gatt.discoverServices()&#10;&#10;            }&#10;&#10;&#10;        }&#10;&#10;        override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {&#10;            super.onMtuChanged(gatt, mtu, status)&#10;            //    state = state.copy(gatt = gatt, mtu = mtu)&#10;            //    currentOnStateChange(state)&#10;        }&#10;&#10;        @SuppressLint(&quot;MissingPermission&quot;)&#10;        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;            super.onServicesDiscovered(gatt, status)&#10;            //      state = state.copy(services = gatt.services)&#10;            //     currentOnStateChange(state)&#10;            val service = gatt.services?.find { it.uuid == SERVICE_UUID }&#10;&#10;            // If the GATTServerSample service is found, get the characteristic&#10;            characteristic = service?.getCharacteristic(CHARACTERISTIC_UUID)&#10;            fusedLocationClient.lastLocation.addOnSuccessListener {&#10;                locationResultVar = it&#10;                sendData(gatt, characteristic)&#10;            }&#10;            fusedLocationClient.requestLocationUpdates(&#10;                LocationRequest.Builder(&#10;                    Priority.PRIORITY_HIGH_ACCURACY,&#10;                    5000,&#10;&#10;                    ).build(), locationCallback, Looper.getMainLooper()&#10;            )&#10;&#10;&#10;        }&#10;&#10;        override fun onCharacteristicWrite(&#10;            gatt: BluetoothGatt?,&#10;            characteristic: BluetoothGattCharacteristic?,&#10;            status: Int,&#10;        ) {&#10;            super.onCharacteristicWrite(gatt, characteristic, status)&#10;            //     state = state.copy(messageSent = status == BluetoothGatt.GATT_SUCCESS)&#10;            //     currentOnStateChange(state)&#10;        }&#10;&#10;        @Suppress(&quot;DEPRECATION&quot;, &quot;OVERRIDE_DEPRECATION&quot;)&#10;        override fun onCharacteristicRead(&#10;            gatt: BluetoothGatt,&#10;            characteristic: BluetoothGattCharacteristic,&#10;            status: Int,&#10;        ) {&#10;            super.onCharacteristicRead(gatt, characteristic, status)&#10;            //   if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;            doOnRead(characteristic.value)&#10;            //    }&#10;        }&#10;&#10;        override fun onCharacteristicRead(&#10;            gatt: BluetoothGatt,&#10;            characteristic: BluetoothGattCharacteristic,&#10;            value: ByteArray,&#10;            status: Int,&#10;        ) {&#10;            super.onCharacteristicRead(gatt, characteristic, value, status)&#10;            doOnRead(value)&#10;        }&#10;&#10;        private fun doOnRead(value: ByteArray) {&#10;            //     state = state.copy(messageReceived = value.decodeToString())&#10;            //      currentOnStateChange(state)&#10;        }&#10;    }&#10;&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        startAsForegroundService()&#10;&#10;        this.startId = startId;&#10;&#10;        val address = intent?.getStringExtra(&quot;address&quot;)&#10;        var device: BluetoothDevice? = null&#10;&#10;        // if(address == null)&#10;&#10;        /* if(gatt1?.)*/&#10;&#10;        /*   bluetoothManager.getConnectedDevices(BluetoothGatt.GATT).forEach {&#10;               if (it.address == address) {&#10;                   device = it&#10;               }&#10;           }*/&#10;&#10;        device = bluetoothManager.adapter.getRemoteDevice(address)&#10;        Log.i(&quot;ayup&quot;,&quot;ON START YEAH&quot;)&#10;&#10;&#10;        if (gatt1 != null) {&#10;            Log.i(&quot;ayup&quot;, &quot;Gatt will be reused&quot;)&#10;            //     gatt1?.connect()&#10;        } else {&#10;            Log.i(&quot;ayup&quot;, &quot;Gatt will be created&quot;)&#10;&#10;            gatt1 = device?.connectGatt(this, true, callback)&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onDestroy() {&#10;        gatt1?.disconnect()&#10;        gatt1?.close()&#10;        shutdownTimer.cancel()&#10;        shutdownTimer.purge()&#10;        fusedLocationClient.removeLocationUpdates(locationCallback)&#10;        super.onDestroy()&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        /* if (missingPermissions()) {&#10;             Log.e(CompanionDeviceSampleService::class.java.toString(),&quot;aaa&quot;);&#10;             return&#10;         }*/&#10;&#10;&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)&#10;        locationCallback = object : LocationCallback() {&#10;            override fun onLocationResult(fetchedLocation: LocationResult) {&#10;                //Log.i(&quot;ayup&quot;, &quot;Location result received &quot; + fetchedLocation.lastLocation.toString())&#10;&#10;                // any location is better than none for now&#10;                val lastLocation = fetchedLocation.lastLocation&#10;                if (locationResultVar.provider.equals(&quot;&quot;) &amp;&amp; lastLocation != null) {&#10;                    locationResultVar = lastLocation&#10;                    return&#10;                }&#10;&#10;                if (lastLocation != null) {&#10;                    // new location is way less accurate, only take if the old location is very old&#10;                    if ((lastLocation.accuracy - locationResultVar.accuracy) &gt; 200) {&#10;                        Log.w(&#10;                            &quot;LOCATION&quot;,&#10;                            &quot;New location is way less accurate than the old one, will only update if the last location is older than 5 minutes&quot;&#10;                        )&#10;                        if (lastLocation.time - locationResultVar.time &gt; 1000 * 60 * 5) {&#10;                            Log.d(&#10;                                &quot;LOCATION&quot;,&#10;                                &quot;Last accurate location is older than 5 minutes, updating anyway&quot;&#10;                            )&#10;                            locationResultVar = lastLocation&#10;                        }&#10;                    } else {&#10;                        Log.w(&#10;                            &quot;LOCATION&quot;,&#10;                            &quot;New location is more accurate than the old one, updating&quot;&#10;                        )&#10;                        locationResultVar = lastLocation&#10;                    }&#10;&#10;                }&#10;                sendData(gatt1, characteristic)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startAsForegroundService() {&#10;        // create the notification channel&#10;        NotificationsHelper.createNotificationChannel(this)&#10;&#10;        // promote service to foreground service&#10;        ServiceCompat.startForeground(&#10;            this,&#10;            1,&#10;            NotificationsHelper.buildNotification(this),&#10;                ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION.or(ServiceInfo.FOREGROUND_SERVICE_TYPE_CONNECTED_DEVICE)&#10;        )&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun sendData(&#10;        gatt: BluetoothGatt?,&#10;        characteristic: BluetoothGattCharacteristic?,&#10;    ) {&#10;        val data = ByteArray(95)&#10;&#10;        data[0] = 0x00&#10;        data[1] = 0x5D.toByte()&#10;&#10;&#10;        // bytes 2-4&#10;        val fixedData = &quot;0802FC&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;        System.arraycopy(fixedData, 0, data, 2, fixedData.size)&#10;&#10;        // transmit timezone offset? NO&#10;        data[5] = 0x00.toByte()&#10;&#10;        val fixedData2 = &quot;0000101010&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;&#10;        System.arraycopy(fixedData2, 0, data, 6, fixedData2.size)&#10;        // position information&#10;        //  Log.e(&quot;thisThing&quot;, locationResultVar!!.latitude.toString());&#10;        val latitude = locationResultVar.latitude&#10;        val longitude = locationResultVar.longitude&#10;        val locationData = set_location(latitude, longitude)&#10;        System.arraycopy(locationData, 0, data, 11, locationData.size)&#10;&#10;        // get the timezone based on the position&#10;        // only use for the offset (currently unused as camera does the thing correctly)&#10;        val timezone = TimeZone.getDefault()&#10;&#10;        // here UTC time must be used&#10;        val dateData = set_date(TimeZone.getTimeZone(&quot;UTC&quot;).toZoneId())&#10;        System.arraycopy(dateData, 0, data, 19, dateData.size)&#10;        // Set the last offsets&#10;        // timezone offset&#10;        /*    val calendar = Calendar.getInstance(timezone)&#10;            val offsetMin = calendar.get(Calendar.ZONE_OFFSET) / 60000&#10;            val offsetMinBytes = ByteBuffer.allocate(2).putShort(offsetMin.toShort()).array()&#10;    */&#10;        // dst offset&#10;        /* val offsetDstMin = calendar.get(Calendar.DST_OFFSET) / 60000&#10;         val offsetDstMinBytes = ByteBuffer.allocate(2).putShort(offsetDstMin.toShort()).array()*/&#10;&#10;&#10;        // TODO does weird stuff, probably not needed as camera has TZ configured&#10;        /*   data[91] = offsetMinBytes[0]&#10;           data[92] = offsetMinBytes[1]&#10;           data[93] = offsetDstMinBytes[0]&#10;           data[94] = offsetDstMinBytes[1]*/&#10;&#10;        val hex = data.toHex()&#10;        Log.i(&quot;ayup&quot;, &quot;Sending data: $hex with location $locationResultVar&quot;)&#10;&#10;            if (characteristic != null) {&#10;                val result = gatt?.writeCharacteristic(&#10;                    characteristic,&#10;                    data,&#10;                    BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT,&#10;                )&#10;                Log.i(&quot;ayup&quot;, &quot;Write result: $result&quot;)&#10;            }&#10;    }&#10;}&#10;&#10;fun ByteArray.toHex(): String = joinToString(separator = &quot;&quot;) { eachByte -&gt; &quot;%02x&quot;.format(eachByte) }" />
              <option name="updatedContent" value="package com.saschl.sonygps.service&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.Service&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothManager&#10;import android.content.Intent&#10;import android.content.pm.ServiceInfo&#10;import android.location.Location&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import androidx.annotation.RequiresApi&#10;import androidx.core.app.ServiceCompat&#10;import androidx.core.content.getSystemService&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.Priority&#10;import com.saschl.sonygps.notification.NotificationsHelper&#10;import com.saschl.sonygps.service.CompanionDeviceSampleService.DeviceNotificationManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import timber.log.Timber&#10;import java.util.TimeZone&#10;import java.util.Timer&#10;import java.util.TimerTask&#10;import java.util.UUID&#10;&#10;class LocationSenderService : Service() {&#10;&#10;    private var startId: Int = 0&#10;    private val binder = LocalBinder()&#10;&#10;    private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;    private lateinit var locationCallback: LocationCallback&#10;    private var gatt1: BluetoothGatt? = null&#10;&#10;    private var characteristic: BluetoothGattCharacteristic? = null&#10;&#10;    private var locationResultVar: Location = Location(&quot;&quot;)&#10;&#10;    private var shutdownTimer = Timer()&#10;&#10;    companion object {&#10;&#10;        // Random UUID for our service known between the client and server to allow communication&#10;        val SERVICE_UUID: UUID = UUID.fromString(&quot;8000dd00-dd00-ffff-ffff-ffffffffffff&quot;)&#10;&#10;        // Same as the service but for the characteristic&#10;        val CHARACTERISTIC_UUID: UUID = UUID.fromString(&quot;0000dd11-0000-1000-8000-00805f9b34fb&quot;)&#10;&#10;&#10;        // Important: this is just for simplicity, there are better ways to communicate between&#10;        // a service and an activity/view&#10;        val serverLogsState: MutableStateFlow&lt;String&gt; = MutableStateFlow(&quot;&quot;)&#10;        val isServerRunning = MutableStateFlow(false)&#10;&#10;        private const val CHANNEL = &quot;gatt_server_channel&quot;&#10;    }&#10;&#10;    private val notificationManager: DeviceNotificationManager by lazy {&#10;        DeviceNotificationManager(applicationContext)&#10;    }&#10;&#10;    private val bluetoothManager: BluetoothManager by lazy {&#10;        applicationContext.getSystemService()!!&#10;    }&#10;&#10;&#10;    inner class LocalBinder : Binder() {&#10;        fun getService(): LocationSenderService = this@LocationSenderService&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder {&#10;        return binder&#10;    }&#10;&#10;    private val callback = object : BluetoothGattCallback() {&#10;        @SuppressLint(&quot;MissingPermission&quot;)&#10;        override fun onConnectionStateChange(&#10;            gatt: BluetoothGatt,&#10;            status: Int,&#10;            newState: Int,&#10;        ) {&#10;            super.onConnectionStateChange(gatt, status, newState)&#10;&#10;            // state = state.copy(gatt = gatt, connectionState = newState)&#10;            //  currentOnStateChange(state)&#10;&#10;            if (status != BluetoothGatt.GATT_SUCCESS) {&#10;                // Here you should handle the error returned in status based on the constants&#10;                // https://developer.android.com/reference/android/bluetooth/BluetoothGatt#summary&#10;                // For example for GATT_INSUFFICIENT_ENCRYPTION or&#10;                // GATT_INSUFFICIENT_AUTHENTICATION you should create a bond.&#10;                // https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createBond()&#10;&#10;                Timber.e(&quot;BLEConnectEffect&quot;, &quot;An error happened: $status&quot;)&#10;                fusedLocationClient.removeLocationUpdates(locationCallback)&#10;                shutdownTimer = Timer()&#10;               /* shutdownTimer.schedule(object : TimerTask() {&#10;                    override fun run() {&#10;&#10;                        Log.e(&quot;LocationSenderService&quot;, &quot;Disconnecting and closing&quot;)&#10;                        gatt.disconnect()&#10;                        gatt.close()&#10;                        stopSelf(startId)&#10;                    }&#10;&#10;                }, 120000)*/&#10;            } else {&#10;                shutdownTimer.cancel()&#10;                shutdownTimer.purge()&#10;&#10;                Timber.i(&quot;BLEConnectEffect&quot;, &quot;Connected to device&quot;)&#10;                gatt.discoverServices()&#10;&#10;            }&#10;&#10;&#10;        }&#10;&#10;        override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {&#10;            super.onMtuChanged(gatt, mtu, status)&#10;            //    state = state.copy(gatt = gatt, mtu = mtu)&#10;            //    currentOnStateChange(state)&#10;        }&#10;&#10;        @SuppressLint(&quot;MissingPermission&quot;)&#10;        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;            super.onServicesDiscovered(gatt, status)&#10;            //      state = state.copy(services = gatt.services)&#10;            //     currentOnStateChange(state)&#10;            val service = gatt.services?.find { it.uuid == SERVICE_UUID }&#10;&#10;            // If the GATTServerSample service is found, get the characteristic&#10;            characteristic = service?.getCharacteristic(CHARACTERISTIC_UUID)&#10;            fusedLocationClient.lastLocation.addOnSuccessListener {&#10;                locationResultVar = it&#10;                sendData(gatt, characteristic)&#10;            }&#10;            fusedLocationClient.requestLocationUpdates(&#10;                LocationRequest.Builder(&#10;                    Priority.PRIORITY_HIGH_ACCURACY,&#10;                    5000,&#10;&#10;                    ).build(), locationCallback, Looper.getMainLooper()&#10;            )&#10;&#10;&#10;        }&#10;&#10;        override fun onCharacteristicWrite(&#10;            gatt: BluetoothGatt?,&#10;            characteristic: BluetoothGattCharacteristic?,&#10;            status: Int,&#10;        ) {&#10;            super.onCharacteristicWrite(gatt, characteristic, status)&#10;            //     state = state.copy(messageSent = status == BluetoothGatt.GATT_SUCCESS)&#10;            //     currentOnStateChange(state)&#10;        }&#10;&#10;        @Suppress(&quot;DEPRECATION&quot;, &quot;OVERRIDE_DEPRECATION&quot;)&#10;        override fun onCharacteristicRead(&#10;            gatt: BluetoothGatt,&#10;            characteristic: BluetoothGattCharacteristic,&#10;            status: Int,&#10;        ) {&#10;            super.onCharacteristicRead(gatt, characteristic, status)&#10;            //   if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;            doOnRead(characteristic.value)&#10;            //    }&#10;        }&#10;&#10;        override fun onCharacteristicRead(&#10;            gatt: BluetoothGatt,&#10;            characteristic: BluetoothGattCharacteristic,&#10;            value: ByteArray,&#10;            status: Int,&#10;        ) {&#10;            super.onCharacteristicRead(gatt, characteristic, value, status)&#10;            doOnRead(value)&#10;        }&#10;&#10;        private fun doOnRead(value: ByteArray) {&#10;            //     state = state.copy(messageReceived = value.decodeToString())&#10;            //      currentOnStateChange(state)&#10;        }&#10;    }&#10;&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        startAsForegroundService()&#10;&#10;        this.startId = startId;&#10;&#10;        val address = intent?.getStringExtra(&quot;address&quot;)&#10;        var device: BluetoothDevice? = null&#10;&#10;        // if(address == null)&#10;&#10;        /* if(gatt1?.)*/&#10;&#10;        /*   bluetoothManager.getConnectedDevices(BluetoothGatt.GATT).forEach {&#10;               if (it.address == address) {&#10;                   device = it&#10;               }&#10;           }*/&#10;&#10;        device = bluetoothManager.adapter.getRemoteDevice(address)&#10;        Timber.i(&quot;ayup&quot;,&quot;ON START YEAH&quot;)&#10;&#10;&#10;        if (gatt1 != null) {&#10;            Timber.i(&quot;ayup&quot;, &quot;Gatt will be reused&quot;)&#10;            //     gatt1?.connect()&#10;        } else {&#10;            Timber.i(&quot;ayup&quot;, &quot;Gatt will be created&quot;)&#10;&#10;            gatt1 = device?.connectGatt(this, true, callback)&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onDestroy() {&#10;        gatt1?.disconnect()&#10;        gatt1?.close()&#10;        shutdownTimer.cancel()&#10;        shutdownTimer.purge()&#10;        fusedLocationClient.removeLocationUpdates(locationCallback)&#10;        super.onDestroy()&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        /* if (missingPermissions()) {&#10;             Log.e(CompanionDeviceSampleService::class.java.toString(),&quot;aaa&quot;);&#10;             return&#10;         }*/&#10;&#10;&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)&#10;        locationCallback = object : LocationCallback() {&#10;            override fun onLocationResult(fetchedLocation: LocationResult) {&#10;                //Log.i(&quot;ayup&quot;, &quot;Location result received &quot; + fetchedLocation.lastLocation.toString())&#10;&#10;                // any location is better than none for now&#10;                val lastLocation = fetchedLocation.lastLocation&#10;                if (locationResultVar.provider.equals(&quot;&quot;) &amp;&amp; lastLocation != null) {&#10;                    locationResultVar = lastLocation&#10;                    return&#10;                }&#10;&#10;                if (lastLocation != null) {&#10;                    // new location is way less accurate, only take if the old location is very old&#10;                    if ((lastLocation.accuracy - locationResultVar.accuracy) &gt; 200) {&#10;                        Timber.w(&#10;                            &quot;LOCATION&quot;,&#10;                            &quot;New location is way less accurate than the old one, will only update if the last location is older than 5 minutes&quot;&#10;                        )&#10;                        if (lastLocation.time - locationResultVar.time &gt; 1000 * 60 * 5) {&#10;                            Timber.d(&#10;                                &quot;LOCATION&quot;,&#10;                                &quot;Last accurate location is older than 5 minutes, updating anyway&quot;&#10;                            )&#10;                            locationResultVar = lastLocation&#10;                        }&#10;                    } else {&#10;                        Timber.w(&#10;                            &quot;LOCATION&quot;,&#10;                            &quot;New location is more accurate than the old one, updating&quot;&#10;                        )&#10;                        locationResultVar = lastLocation&#10;                    }&#10;&#10;                }&#10;                sendData(gatt1, characteristic)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startAsForegroundService() {&#10;        // create the notification channel&#10;        NotificationsHelper.createNotificationChannel(this)&#10;&#10;        // promote service to foreground service&#10;        ServiceCompat.startForeground(&#10;            this,&#10;            1,&#10;            NotificationsHelper.buildNotification(this),&#10;                ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION.or(ServiceInfo.FOREGROUND_SERVICE_TYPE_CONNECTED_DEVICE)&#10;        )&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun sendData(&#10;        gatt: BluetoothGatt?,&#10;        characteristic: BluetoothGattCharacteristic?,&#10;    ) {&#10;        val data = ByteArray(95)&#10;&#10;        data[0] = 0x00&#10;        data[1] = 0x5D.toByte()&#10;&#10;&#10;        // bytes 2-4&#10;        val fixedData = &quot;0802FC&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;        System.arraycopy(fixedData, 0, data, 2, fixedData.size)&#10;&#10;        // transmit timezone offset? NO&#10;        data[5] = 0x00.toByte()&#10;&#10;        val fixedData2 = &quot;0000101010&quot;.chunked(2)&#10;            .map { it.toInt(16).toByte() }&#10;            .toByteArray()&#10;&#10;        System.arraycopy(fixedData2, 0, data, 6, fixedData2.size)&#10;        // position information&#10;        //  Log.e(&quot;thisThing&quot;, locationResultVar!!.latitude.toString());&#10;        val latitude = locationResultVar.latitude&#10;        val longitude = locationResultVar.longitude&#10;        val locationData = set_location(latitude, longitude)&#10;        System.arraycopy(locationData, 0, data, 11, locationData.size)&#10;&#10;        // get the timezone based on the position&#10;        // only use for the offset (currently unused as camera does the thing correctly)&#10;        val timezone = TimeZone.getDefault()&#10;&#10;        // here UTC time must be used&#10;        val dateData = set_date(TimeZone.getTimeZone(&quot;UTC&quot;).toZoneId())&#10;        System.arraycopy(dateData, 0, data, 19, dateData.size)&#10;        // Set the last offsets&#10;        // timezone offset&#10;        /*    val calendar = Calendar.getInstance(timezone)&#10;            val offsetMin = calendar.get(Calendar.ZONE_OFFSET) / 60000&#10;            val offsetMinBytes = ByteBuffer.allocate(2).putShort(offsetMin.toShort()).array()&#10;    */&#10;        // dst offset&#10;        /* val offsetDstMin = calendar.get(Calendar.DST_OFFSET) / 60000&#10;         val offsetDstMinBytes = ByteBuffer.allocate(2).putShort(offsetDstMin.toShort()).array()*/&#10;&#10;&#10;        // TODO does weird stuff, probably not needed as camera has TZ configured&#10;        /*   data[91] = offsetMinBytes[0]&#10;           data[92] = offsetMinBytes[1]&#10;           data[93] = offsetDstMinBytes[0]&#10;           data[94] = offsetDstMinBytes[1]*/&#10;&#10;        val hex = data.toHex()&#10;        Timber.i(&quot;ayup&quot;, &quot;Sending data: $hex with location $locationResultVar&quot;)&#10;&#10;            if (characteristic != null) {&#10;                val result = gatt?.writeCharacteristic(&#10;                    characteristic,&#10;                    data,&#10;                    BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT,&#10;                )&#10;                Timber.i(&quot;ayup&quot;, &quot;Write result: $result&quot;)&#10;            }&#10;    }&#10;}&#10;&#10;fun ByteArray.toHex(): String = joinToString(separator = &quot;&quot;) { eachByte -&gt; &quot;%02x&quot;.format(eachByte) }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/ui/Rerer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/ui/Rerer.kt" />
              <option name="originalContent" value="package com.saschl.sonygps.ui&#10;&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.LinearLayout&#10;import android.widget.ScrollView&#10;import android.widget.TextView&#10;import androidx.activity.ComponentActivity&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.saschl.sonygps.service.FileTree&#10;&#10;class LogViewerActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        val mainLayout = LinearLayout(this).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            setPadding(16, 16, 16, 16)&#10;        }&#10;&#10;        // Title bar&#10;        val titleView = TextView(this).apply {&#10;            text = &quot;Application Logs&quot;&#10;            textSize = 24f&#10;            setPadding(0, 0, 0, 16)&#10;            setTypeface(null, android.graphics.Typeface.BOLD)&#10;        }&#10;&#10;        // Log content in scrollable view&#10;        val scrollView = ScrollView(this)&#10;        val logTextView = TextView(this).apply {&#10;            text = if (FileTree.getLogs().isEmpty()) {&#10;                &quot;No logs available yet. Logs will appear here as the app runs.&quot;&#10;            } else {&#10;                FileTree.getLogs().joinToString(&quot;\n\n&quot;)&#10;            }&#10;            setTextIsSelectable(true)&#10;            setPadding(16, 16, 16, 16)&#10;            setBackgroundColor(0xFFF5F5F5.toInt()) // Light gray background&#10;            textSize = 12f&#10;        }&#10;&#10;        // Clear logs button&#10;        val clearButton = Button(this).apply {&#10;            text = &quot;Clear All Logs&quot;&#10;            setOnClickListener {&#10;                FileTree.clearLogs()&#10;                // Refresh the log display&#10;                logTextView.text = &quot;Logs cleared. New logs will appear here as the app runs.&quot;&#10;            }&#10;        }&#10;&#10;        scrollView.addView(logTextView)&#10;        mainLayout.addView(titleView)&#10;        mainLayout.addView(clearButton)&#10;        mainLayout.addView(scrollView)&#10;&#10;        setContentView(mainLayout)&#10;&#10;        // Handle system bars (status bar, navigation bar)&#10;        ViewCompat.setOnApplyWindowInsetsListener(mainLayout) { view, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            view.setPadding(16, systemBars.top + 16, 16, systemBars.bottom + 16)&#10;            insets&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.saschl.sonygps.ui&#10;&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.LinearLayout&#10;import android.widget.TextView&#10;import androidx.activity.ComponentActivity&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout&#10;import com.saschl.sonygps.service.FileTree&#10;&#10;class LogViewerActivity : ComponentActivity() {&#10;    private lateinit var logTextView: TextView&#10;    private lateinit var swipeRefreshLayout: SwipeRefreshLayout&#10;    &#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        val mainLayout = LinearLayout(this).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            setPadding(16, 16, 16, 16)&#10;        }&#10;&#10;        // Title bar&#10;        val titleView = TextView(this).apply {&#10;            text = &quot;Application Logs&quot;&#10;            textSize = 24f&#10;            setPadding(0, 0, 0, 16)&#10;            setTypeface(null, android.graphics.Typeface.BOLD)&#10;        }&#10;&#10;        // Clear logs button&#10;        val clearButton = Button(this).apply {&#10;            text = &quot;Clear All Logs&quot;&#10;            setOnClickListener {&#10;                FileTree.clearLogs()&#10;                refreshLogs()&#10;            }&#10;        }&#10;&#10;        // SwipeRefreshLayout containing the log content&#10;        swipeRefreshLayout = SwipeRefreshLayout(this).apply {&#10;            setOnRefreshListener {&#10;                refreshLogs()&#10;            }&#10;            // Set refresh colors&#10;            setColorSchemeResources(&#10;                android.R.color.holo_blue_bright,&#10;                android.R.color.holo_green_light,&#10;                android.R.color.holo_orange_light,&#10;                android.R.color.holo_red_light&#10;            )&#10;        }&#10;&#10;        // Log content in scrollable view&#10;        logTextView = TextView(this).apply {&#10;            setTextIsSelectable(true)&#10;            setPadding(16, 16, 16, 16)&#10;            setBackgroundColor(0xFFF5F5F5.toInt()) // Light gray background&#10;            textSize = 12f&#10;        }&#10;&#10;        // Load initial logs&#10;        refreshLogs()&#10;&#10;        swipeRefreshLayout.addView(logTextView)&#10;        mainLayout.addView(titleView)&#10;        mainLayout.addView(clearButton)&#10;        mainLayout.addView(swipeRefreshLayout)&#10;&#10;        setContentView(mainLayout)&#10;&#10;        // Handle system bars (status bar, navigation bar)&#10;        ViewCompat.setOnApplyWindowInsetsListener(mainLayout) { view, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            view.setPadding(16, systemBars.top + 16, 16, systemBars.bottom + 16)&#10;            insets&#10;        }&#10;    }&#10;    &#10;    private fun refreshLogs() {&#10;        val logs = FileTree.getLogs()&#10;        logTextView.text = if (logs.isEmpty()) {&#10;            &quot;No logs available yet. Logs will appear here as the app runs.\n\nPull down to refresh and fetch new logs.&quot;&#10;        } else {&#10;            logs.joinToString(&quot;\n\n&quot;)&#10;        }&#10;        &#10;        // Stop the refresh animation&#10;        swipeRefreshLayout.isRefreshing = false&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle/libs.versions.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle/libs.versions.toml" />
              <option name="originalContent" value="[versions]&#10;agp = &quot;8.11.1&quot;&#10;kotlin = &quot;1.9.25&quot;&#10;coreKtx = &quot;1.12.0&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.1.5&quot;&#10;espressoCore = &quot;3.5.1&quot;&#10;appcompat = &quot;1.6.1&quot;&#10;material = &quot;1.10.0&quot;&#10;lifecycleRuntimeKtx = &quot;2.8.7&quot;&#10;activityCompose = &quot;1.9.3&quot;&#10;composeBom = &quot;2024.12.01&quot;&#10;googlePlayServicesLocation = &quot;21.3.0&quot;&#10;accompanist = &quot;0.32.0&quot;&#10;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-appcompat = { group = &quot;androidx.appcompat&quot;, name = &quot;appcompat&quot;, version.ref = &quot;appcompat&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;google-play-services-location = { group = &quot;com.google.android.gms&quot;, name = &quot;play-services-location&quot;, version.ref = &quot;googlePlayServicesLocation&quot; }&#10;accompanist-permissions = { module = &quot;com.google.accompanist:accompanist-permissions&quot;, version.ref = &quot;accompanist&quot; }&#10;timber = { group = &quot;com.jakewharton.timber&quot;, name = &quot;timber&quot;, version = &quot;5.0.1&quot; }&#10;&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;&#10;" />
              <option name="updatedContent" value="[versions]&#10;agp = &quot;8.11.1&quot;&#10;kotlin = &quot;1.9.25&quot;&#10;coreKtx = &quot;1.12.0&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.1.5&quot;&#10;espressoCore = &quot;3.5.1&quot;&#10;appcompat = &quot;1.6.1&quot;&#10;material = &quot;1.10.0&quot;&#10;lifecycleRuntimeKtx = &quot;2.8.7&quot;&#10;activityCompose = &quot;1.9.3&quot;&#10;composeBom = &quot;2024.12.01&quot;&#10;googlePlayServicesLocation = &quot;21.3.0&quot;&#10;accompanist = &quot;0.32.0&quot;&#10;room = &quot;2.6.1&quot;&#10;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-appcompat = { group = &quot;androidx.appcompat&quot;, name = &quot;appcompat&quot;, version.ref = &quot;appcompat&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;google-play-services-location = { group = &quot;com.google.android.gms&quot;, name = &quot;play-services-location&quot;, version.ref = &quot;googlePlayServicesLocation&quot; }&#10;accompanist-permissions = { module = &quot;com.google.accompanist:accompanist-permissions&quot;, version.ref = &quot;accompanist&quot; }&#10;timber = { group = &quot;com.jakewharton.timber&quot;, name = &quot;timber&quot;, version = &quot;5.0.1&quot; }&#10;androidx-room-runtime = { group = &quot;androidx.room&quot;, name = &quot;room-runtime&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-compiler = { group = &quot;androidx.room&quot;, name = &quot;room-compiler&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-ktx = { group = &quot;androidx.room&quot;, name = &quot;room-ktx&quot;, version.ref = &quot;room&quot; }&#10;&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>