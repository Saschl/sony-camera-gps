<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/MainActivity.kt" />
              <option name="originalContent" value="package com.saschl.sonygps&#10;&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.LinearLayout&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.saschl.sonygps.service.CompanionDeviceManagerSample&#10;import com.saschl.sonygps.service.FileTree&#10;import com.saschl.sonygps.service.GlobalExceptionHandler&#10;import timber.log.Timber&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;&#10;    // needed to communicate with the service.&#10;&#10;    // we need notification permission to be able to display a notification for the foreground service&#10;    private val notificationPermissionLauncher =&#10;        registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) {&#10;            // if permission was denied, the service can still run only the notification won't be visible&#10;        }&#10;&#10;    // we need location permission to be able to start the service&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Only plant Timber once in the app lifecycle&#10;        //if (Timber.treeCount == 0) {&#10;            FileTree.initialize(this)&#10;            Timber.plant(Timber.DebugTree(), FileTree(this))&#10;&#10;            // Set up global exception handler to log crashes&#10;            val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()&#10;            Thread.setDefaultUncaughtExceptionHandler(GlobalExceptionHandler(defaultHandler))&#10;      //  }&#10;&#10;        Timber.i(&quot;onCreate called&quot;)&#10;&#10;        val layout = LinearLayout(this)&#10;        layout.orientation = LinearLayout.VERTICAL&#10;        layout.setPadding(16, 16, 16, 16)&#10;&#10;        val logButton = Button(this).apply {&#10;            text = &quot;View Logs&quot;&#10;            setOnClickListener {&#10;                startActivity(Intent(this@MainActivity, com.saschl.sonygps.ui.LogViewerActivity::class.java))&#10;            }&#10;        }&#10;        layout.addView(logButton)&#10;        val composeView = androidx.compose.ui.platform.ComposeView(this).apply {&#10;            setContent { CompanionDeviceManagerSample() }&#10;        }&#10;        layout.addView(composeView)&#10;        setContentView(layout)&#10;&#10;        // Handle system bars to prevent button from appearing in status bar&#10;        ViewCompat.setOnApplyWindowInsetsListener(layout) { view, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            view.setPadding(16, systemBars.top + 16, 16, systemBars.bottom + 16)&#10;            insets&#10;        }&#10;&#10;        checkAndRequestNotificationPermission()&#10;&#10;    }&#10;&#10;&#10;    /**&#10;     * Check for notification permission before starting the service so that the notification is visible&#10;     */&#10;    private fun checkAndRequestNotificationPermission() {&#10;        when (ContextCompat.checkSelfPermission(&#10;            this,&#10;            android.Manifest.permission.POST_NOTIFICATIONS&#10;        )) {&#10;            android.content.pm.PackageManager.PERMISSION_GRANTED -&gt; {&#10;                // permission already granted&#10;            }&#10;&#10;            else -&gt; {&#10;                notificationPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MainActivity&quot;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.saschl.sonygps&#10;&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.LinearLayout&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.saschl.sonygps.service.CompanionDeviceManagerSample&#10;import com.saschl.sonygps.service.FileTree&#10;import com.saschl.sonygps.service.GlobalExceptionHandler&#10;import com.saschl.sonygps.ui.theme.ForegroundService14Theme&#10;import timber.log.Timber&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;&#10;    // needed to communicate with the service.&#10;&#10;    // we need notification permission to be able to display a notification for the foreground service&#10;    private val notificationPermissionLauncher =&#10;        registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) {&#10;            // if permission was denied, the service can still run only the notification won't be visible&#10;        }&#10;&#10;    // we need location permission to be able to start the service&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Only plant Timber once in the app lifecycle&#10;        //if (Timber.treeCount == 0) {&#10;            FileTree.initialize(this)&#10;            Timber.plant(Timber.DebugTree(), FileTree(this))&#10;&#10;            // Set up global exception handler to log crashes&#10;            val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()&#10;            Thread.setDefaultUncaughtExceptionHandler(GlobalExceptionHandler(defaultHandler))&#10;      //  }&#10;&#10;        Timber.i(&quot;onCreate called&quot;)&#10;&#10;        val layout = LinearLayout(this)&#10;        layout.orientation = LinearLayout.VERTICAL&#10;        layout.setPadding(16, 16, 16, 16)&#10;&#10;        val logButton = Button(this).apply {&#10;            text = &quot;View Logs&quot;&#10;            setOnClickListener {&#10;                startActivity(Intent(this@MainActivity, com.saschl.sonygps.ui.LogViewerActivity::class.java))&#10;            }&#10;        }&#10;        layout.addView(logButton)&#10;        val composeView = androidx.compose.ui.platform.ComposeView(this).apply {&#10;            setContent { &#10;                ForegroundService14Theme {&#10;                    CompanionDeviceManagerSample() &#10;                }&#10;            }&#10;        }&#10;        layout.addView(composeView)&#10;        setContentView(layout)&#10;&#10;        // Handle system bars to prevent button from appearing in status bar&#10;        ViewCompat.setOnApplyWindowInsetsListener(layout) { view, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            view.setPadding(16, systemBars.top + 16, 16, systemBars.bottom + 16)&#10;            insets&#10;        }&#10;&#10;        checkAndRequestNotificationPermission()&#10;&#10;    }&#10;&#10;&#10;    /**&#10;     * Check for notification permission before starting the service so that the notification is visible&#10;     */&#10;    private fun checkAndRequestNotificationPermission() {&#10;        when (ContextCompat.checkSelfPermission(&#10;            this,&#10;            android.Manifest.permission.POST_NOTIFICATIONS&#10;        )) {&#10;            android.content.pm.PackageManager.PERMISSION_GRANTED -&gt; {&#10;                // permission already granted&#10;            }&#10;&#10;            else -&gt; {&#10;                notificationPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MainActivity&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDao.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.Query&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface LogDao {&#10;    @Insert&#10;    suspend fun insertLog(logEntry: LogEntry)&#10;&#10;    @Query(&quot;SELECT * FROM log_entries ORDER BY timestamp DESC&quot;)&#10;    fun getAllLogs(): Flow&lt;List&lt;LogEntry&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM log_entries ORDER BY timestamp DESC LIMIT :limit&quot;)&#10;    suspend fun getRecentLogs(limit: Int = 200): List&lt;LogEntry&gt;&#10;&#10;    @Query(&quot;DELETE FROM log_entries WHERE id NOT IN (SELECT id FROM log_entries ORDER BY timestamp DESC LIMIT :keepCount)&quot;)&#10;    suspend fun deleteOldLogs(keepCount: Int = 500)&#10;&#10;    @Query(&quot;DELETE FROM log_entries&quot;)&#10;    suspend fun clearAllLogs()&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM log_entries&quot;)&#10;    suspend fun getLogCount(): Int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogDatabase.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [LogEntry::class],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;abstract class LogDatabase : RoomDatabase() {&#10;    abstract fun logDao(): LogDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: LogDatabase? = null&#10;&#10;        fun getDatabase(context: Context): LogDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    LogDatabase::class.java,&#10;                    &quot;log_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogEntry.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogEntry.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;log_entries&quot;)&#10;data class LogEntry(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;    val timestamp: Long,&#10;    val priority: Int,&#10;    val tag: String?,&#10;    val message: String,&#10;    val exception: String?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/database/LogRepository.kt" />
              <option name="updatedContent" value="package com.saschl.sonygps.database&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.launch&#10;&#10;class LogRepository(context: Context) {&#10;    private val logDao = LogDatabase.getDatabase(context).logDao()&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    fun insertLog(timestamp: Long, priority: Int, tag: String?, message: String, exception: String?) {&#10;        scope.launch {&#10;            val logEntry = LogEntry(&#10;                timestamp = timestamp,&#10;                priority = priority,&#10;                tag = tag,&#10;                message = message,&#10;                exception = exception&#10;            )&#10;            logDao.insertLog(logEntry)&#10;            &#10;            // Clean up old logs to prevent database from growing too large&#10;            val count = logDao.getLogCount()&#10;            if (count &gt; 1000) {&#10;                logDao.deleteOldLogs(500) // Keep only latest 500 logs&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getAllLogs(): Flow&lt;List&lt;LogEntry&gt;&gt; = logDao.getAllLogs()&#10;&#10;    suspend fun getRecentLogs(limit: Int = 200): List&lt;LogEntry&gt; = logDao.getRecentLogs(limit)&#10;&#10;    fun clearAllLogs() {&#10;        scope.launch {&#10;            logDao.clearAllLogs()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/CompanionDeviceManagerSample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/CompanionDeviceManagerSample.kt" />
              <option name="originalContent" value="/*&#10; * Copyright 2023 The Android Open Source Project&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10; * you may not use this file except in compliance with the License.&#10; * You may obtain a copy of the License at&#10; *&#10; *     https://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10; * See the License for the specific language governing permissions and&#10; * limitations under the License.&#10; */&#10;&#10;package com.saschl.sonygps.service&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothDevice.TRANSPORT_AUTO&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothGattService&#10;import android.bluetooth.BluetoothManager&#10;import android.bluetooth.BluetoothProfile&#10;import android.bluetooth.le.ScanResult&#10;import android.companion.AssociationInfo&#10;import android.companion.AssociationRequest&#10;import android.companion.BluetoothLeDeviceFilter&#10;import android.companion.CompanionDeviceManager&#10;import android.companion.ObservingDevicePresenceRequest&#10;import android.content.Intent&#10;import android.content.IntentSender&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.IntentSenderRequest&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.annotation.RequiresApi&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.SolidColor&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.getSystemService&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.LifecycleOwner&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.saschl.sonygps.service.CompanionDeviceSampleService.Companion.CHARACTERISTIC_UUID&#10;import com.saschl.sonygps.service.CompanionDeviceSampleService.Companion.SERVICE_UUID&#10;import com.saschl.sonygps.ui.PermissionBox&#10;import com.saschl.sonygps.ui.theme.ForegroundService14Theme&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.nio.ByteBuffer&#10;import java.time.Instant&#10;import java.time.ZoneId&#10;import java.time.ZonedDateTime&#10;import java.util.concurrent.Executor&#10;import java.util.regex.Pattern&#10;import kotlin.random.Random&#10;&#10;@Composable&#10;fun CompanionDeviceManagerSample() {&#10;&#10;    ForegroundService14Theme {&#10;        Surface(&#10;            modifier = Modifier.fillMaxSize(),&#10;            color = MaterialTheme.colorScheme.background&#10;        ) {&#10;            val context = LocalContext.current&#10;            val deviceManager = context.getSystemService&lt;CompanionDeviceManager&gt;()&#10;            val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;            var selectedDevice by remember {&#10;                mutableStateOf&lt;BluetoothDevice?&gt;(null)&#10;            }&#10;            if (deviceManager == null || adapter == null) {&#10;                Text(text = &quot;No Companion device manager found. The device does not support it.&quot;)&#10;            } else {&#10;                if (selectedDevice == null) {&#10;                    PermissionBox(&#10;                        permissions = listOf(&#10;                            Manifest.permission.BLUETOOTH_CONNECT,&#10;                            Manifest.permission.ACCESS_FINE_LOCATION&#10;                        )&#10;                    ) {&#10;&#10;                        DevicesScreen(deviceManager) { device -&gt;&#10;                            selectedDevice =&#10;                                (device.device ?: adapter.getRemoteDevice(device.address))&#10;                        }&#10;                    }&#10;                } else {&#10;                    PermissionBox(&#10;                        permissions = listOf(&#10;                            Manifest.permission.BLUETOOTH_CONNECT,&#10;                            Manifest.permission.ACCESS_FINE_LOCATION&#10;                        )&#10;                    ) {&#10;                        ConnectDeviceScreen(device = selectedDevice!!) {&#10;                            selectedDevice = null&#10;                        }&#10;                    }&#10;&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;private data class DeviceConnectionState(&#10;    val gatt: BluetoothGatt?,&#10;    val connectionState: Int,&#10;    val mtu: Int,&#10;    val services: List&lt;BluetoothGattService&gt; = emptyList(),&#10;    val messageSent: Boolean = false,&#10;    val messageReceived: String = &quot;&quot;,&#10;) {&#10;    companion object {&#10;        val None = DeviceConnectionState(null, -1, -1)&#10;    }&#10;}&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;private fun BLEConnectEffect(&#10;    device: BluetoothDevice,&#10;    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,&#10;    onStateChange: (DeviceConnectionState) -&gt; Unit,&#10;) {&#10;    val context = LocalContext.current&#10;    val currentOnStateChange by rememberUpdatedState(onStateChange)&#10;&#10;    // Keep the current connection state&#10;    var state by remember {&#10;        mutableStateOf(DeviceConnectionState.None)&#10;    }&#10;&#10;    DisposableEffect(lifecycleOwner, device) {&#10;        // This callback will notify us when things change in the GATT connection so we can update&#10;        // our state&#10;        val callback = object : BluetoothGattCallback() {&#10;            override fun onConnectionStateChange(&#10;                gatt: BluetoothGatt,&#10;                status: Int,&#10;                newState: Int,&#10;            ) {&#10;                super.onConnectionStateChange(gatt, status, newState)&#10;                state = state.copy(gatt = gatt, connectionState = newState)&#10;                currentOnStateChange(state)&#10;&#10;                if (status != BluetoothGatt.GATT_SUCCESS) {&#10;                    // Here you should handle the error returned in status based on the constants&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothGatt#summary&#10;                    // For example for GATT_INSUFFICIENT_ENCRYPTION or&#10;                    // GATT_INSUFFICIENT_AUTHENTICATION you should create a bond.&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createBond()&#10;                    Log.e(&quot;BLEConnectEffect&quot;, &quot;An error happened: $status&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {&#10;                super.onMtuChanged(gatt, mtu, status)&#10;                state = state.copy(gatt = gatt, mtu = mtu)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;                super.onServicesDiscovered(gatt, status)&#10;                state = state.copy(services = gatt.services)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onCharacteristicWrite(&#10;                gatt: BluetoothGatt?,&#10;                characteristic: BluetoothGattCharacteristic?,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicWrite(gatt, characteristic, status)&#10;                state = state.copy(messageSent = status == BluetoothGatt.GATT_SUCCESS)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            @Suppress(&quot;DEPRECATION&quot;, &quot;OVERRIDE_DEPRECATION&quot;)&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, status)&#10;                //   if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;                doOnRead(characteristic.value)&#10;                //    }&#10;            }&#10;&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                value: ByteArray,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, value, status)&#10;                doOnRead(value)&#10;            }&#10;&#10;            private fun doOnRead(value: ByteArray) {&#10;                state = state.copy(messageReceived = value.decodeToString())&#10;                currentOnStateChange(state)&#10;            }&#10;        }&#10;&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_START) {&#10;                if (state.gatt != null) {&#10;                    // If we previously had a GATT connection let's reestablish it&#10;                    state.gatt?.connect()&#10;                } else {&#10;                    // Otherwise create a new GATT connection&#10;                    state = state.copy(&#10;                        gatt = device.connectGatt(&#10;                            context,&#10;                            false,&#10;                            callback,&#10;                            TRANSPORT_AUTO&#10;                        )&#10;                    )&#10;                }&#10;            } else if (event == Lifecycle.Event.ON_STOP) {&#10;                // Unless you have a reason to keep connected while in the bg you should disconnect&#10;                state.gatt?.disconnect()&#10;            }&#10;        }&#10;&#10;        // Add the observer to the lifecycle&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;        // When the effect leaves the Composition, remove the observer and close the connection&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;            state.gatt?.close()&#10;            state = DeviceConnectionState.None&#10;        }&#10;    }&#10;}&#10;&#10;internal fun Int.toConnectionStateString() = when (this) {&#10;    BluetoothProfile.STATE_CONNECTED -&gt; &quot;Connected&quot;&#10;    BluetoothProfile.STATE_CONNECTING -&gt; &quot;Connecting&quot;&#10;    BluetoothProfile.STATE_DISCONNECTED -&gt; &quot;Disconnected&quot;&#10;    BluetoothProfile.STATE_DISCONNECTING -&gt; &quot;Disconnecting&quot;&#10;    else -&gt; &quot;N/A&quot;&#10;}&#10;&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;fun ConnectDeviceScreen(device: BluetoothDevice, onClose: () -&gt; Unit) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Keeps track of the last connection state with the device&#10;    var state by remember(device) {&#10;        mutableStateOf&lt;DeviceConnectionState?&gt;(null)&#10;    }&#10;    // Once the device services are discovered find the GATTServerSample service&#10;    val service by remember(state) {&#10;        mutableStateOf(state?.services?.find { it.uuid == SERVICE_UUID })&#10;    }&#10;    // If the GATTServerSample service is found, get the characteristic&#10;    val characteristic by remember(service) {&#10;        mutableStateOf(service?.getCharacteristic(CHARACTERISTIC_UUID))&#10;    }&#10;&#10;    // This effect will handle the connection and notify when the state changes&#10;    BLEConnectEffect(device = device) {&#10;        // update our state to recompose the UI&#10;        state = it&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        Text(text = &quot;Devices details&quot;, style = MaterialTheme.typography.headlineSmall)&#10;        Text(text = &quot;Name: ${device.name} (${device.address})&quot;)&#10;        Text(text = &quot;Status: ${state?.connectionState?.toConnectionStateString()}&quot;)&#10;        Text(text = &quot;MTU: ${state?.mtu}&quot;)&#10;        Text(text = &quot;Services: ${state?.services?.joinToString { it.uuid.toString() + &quot; &quot; + it.type }}&quot;)&#10;        Text(text = &quot;Message sent: ${state?.messageSent}&quot;)&#10;        Text(text = &quot;Message received: ${state?.messageReceived}&quot;)&#10;        Button(&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    if (state?.connectionState == BluetoothProfile.STATE_DISCONNECTED) {&#10;                        //      state?.gatt?.connect()&#10;                    }&#10;                    // Example on how to request specific MTUs&#10;                    // Note that from Android 14 onwards the system will define a default MTU and&#10;                    // it will only be sent once to the peripheral device&#10;                    state?.gatt?.requestMtu(Random.nextInt(27, 190))&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Request MTU&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    // Once we have the connection discover the peripheral services&#10;                    state?.gatt?.discoverServices()&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Discover&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                /* scope.launch(Dispatchers.IO) {&#10;                     sendData(state?.gatt!!, characteristic!!)&#10;                 }*/&#10;            },&#10;        ) {&#10;            Text(text = &quot;Write to server&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    state?.gatt?.readCharacteristic(characteristic)&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Read characteristic&quot;)&#10;        }&#10;        Button(onClick = onClose) {&#10;            Text(text = &quot;Close&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;fun set_location(latitude: Double, longitude: Double): ByteArray {&#10;    val myLat = (latitude * 1e7).toInt()&#10;    val myLng = (longitude * 1e7).toInt()&#10;    val myLatByte = ByteBuffer.allocate(4).putInt(myLat).array()&#10;    val myLngByte = ByteBuffer.allocate(4).putInt(myLng).array()&#10;    return myLatByte + myLngByte&#10;}&#10;&#10;fun set_date(zoneId: ZoneId): ByteArray {&#10;    val now = ZonedDateTime.ofInstant(Instant.now(), zoneId)&#10;    val year = now.year.toShort()&#10;    val yearBytes = ByteBuffer.allocate(2).putShort(year).array()&#10;    val hour = now.hour&#10;    return byteArrayOf(&#10;        yearBytes[0], yearBytes[1],&#10;        now.monthValue.toByte(),&#10;        now.dayOfMonth.toByte(),&#10;        now.hour.toByte(),&#10;        now.minute.toByte(),&#10;        now.second.toByte()&#10;    )&#10;}&#10;&#10;&#10;@RequiresApi(Build.VERSION_CODES.O)&#10;@Composable&#10;private fun DevicesScreen(&#10;    deviceManager: CompanionDeviceManager,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var associatedDevices by remember {&#10;        // If we already associated the device no need to do it again.&#10;        mutableStateOf(deviceManager.getAssociatedDevices())&#10;    }&#10;&#10;/*    LaunchedEffect(associatedDevices) {&#10;        associatedDevices.forEach {&#10;            //    deviceManager.startObservingDevicePresence(it.address)&#10;        }&#10;&#10;    }*/&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            Text(&#10;                text = &quot;Sony Camera GPS&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(32.dp),&#10;            )&#10;        }) { innerPadding -&gt;&#10;&#10;        Column(modifier = Modifier&#10;            .padding(innerPadding),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            ScanForDevicesMenu(deviceManager) {&#10;                associatedDevices = associatedDevices + it&#10;            }&#10;            AssociatedDevicesList(&#10;                associatedDevices = associatedDevices,&#10;                onConnect = onConnect,&#10;                onDisassociate = {&#10;                    scope.launch {&#10;                        deviceManager.disassociate(it.id)&#10;&#10;                        deviceManager.stopObservingDevicePresence(it.address)&#10;&#10;                        associatedDevices = deviceManager.getAssociatedDevices()&#10;                    }&#10;                },&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ScanForDevicesMenu(&#10;    deviceManager: CompanionDeviceManager,&#10;    onDeviceAssociated: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var errorMessage by remember {&#10;        mutableStateOf(&quot;&quot;)&#10;    }&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartIntentSenderForResult(),&#10;    ) {&#10;        when (it.resultCode) {&#10;            CompanionDeviceManager.RESULT_OK -&gt; {&#10;                it.data?.getAssociationResult()?.run {&#10;                    onDeviceAssociated(this)&#10;                }&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_CANCELED -&gt; {&#10;                errorMessage = &quot;The request was canceled&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_INTERNAL_ERROR -&gt; {&#10;                errorMessage = &quot;Internal error happened&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_DISCOVERY_TIMEOUT -&gt; {&#10;                errorMessage = &quot;No device matching the given filter were found&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_USER_REJECTED -&gt; {&#10;                errorMessage = &quot;The user explicitly declined the request&quot;&#10;            }&#10;&#10;            else -&gt; {&#10;                errorMessage = &quot;Unknown error&quot;&#10;            }&#10;        }&#10;    }&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(MaterialTheme.colorScheme.primaryContainer)&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;    ) {&#10;        Row {&#10;            Text(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f),&#10;                text = &quot;Find &amp; associate another device running the GATTServerSample&quot;,&#10;            )&#10;            Button(&#10;                modifier = Modifier.weight(0.3f),&#10;                onClick = {&#10;                    scope.launch {&#10;                        val intentSender = requestDeviceAssociation(deviceManager)&#10;                        launcher.launch(IntentSenderRequest.Builder(intentSender).build())&#10;                    }&#10;                },&#10;            ) {&#10;                Text(text = &quot;Start&quot;)&#10;            }&#10;        }&#10;        if (errorMessage.isNotBlank()) {&#10;            Text(text = errorMessage, color = MaterialTheme.colorScheme.error)&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;private fun AssociatedDevicesList(&#10;    associatedDevices: List&lt;AssociatedDeviceCompat&gt;,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;    onDisassociate: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        stickyHeader {&#10;            Text(&#10;                text = &quot;Associated Devices:&quot;,&#10;                modifier = Modifier.padding(vertical = 8.dp),&#10;                style = MaterialTheme.typography.titleMedium,&#10;            )&#10;        }&#10;        items(associatedDevices) { device -&gt;&#10;            Row(&#10;                Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically,&#10;            ) {&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(1f),&#10;                ) {&#10;                    Text(text = &quot;ID: ${device.id}&quot;)&#10;                    Text(text = &quot;MAC: ${device.address}&quot;)&#10;                    Text(text = &quot;Name: ${device.name}&quot;)&#10;                }&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(0.6f),&#10;                    horizontalAlignment = Alignment.End,&#10;                    verticalArrangement = Arrangement.Center,&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = { onConnect(device) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                    ) {&#10;                        Text(text = &quot;Connect&quot;)&#10;                    }&#10;                    OutlinedButton(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        onClick = { onDisassociate(device) },&#10;                        border = ButtonDefaults.outlinedButtonBorder().copy(&#10;                            brush = SolidColor(MaterialTheme.colorScheme.error),&#10;                        ),&#10;                    ) {&#10;                        Text(text = &quot;Disassociate&quot;, color = MaterialTheme.colorScheme.error)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun Intent.getAssociationResult(): AssociatedDeviceCompat? {&#10;&#10;        return getParcelableExtra(&#10;            CompanionDeviceManager.EXTRA_ASSOCIATION,&#10;            AssociationInfo::class.java,&#10;        )?.toAssociatedDevice()&#10;&#10;}&#10;&#10;private suspend fun requestDeviceAssociation(deviceManager: CompanionDeviceManager): IntentSender {&#10;    // Match only Bluetooth devices whose service UUID matches this pattern.&#10;    // For this demo we will match our GATTServerSample&#10;    val deviceFilter = BluetoothLeDeviceFilter.Builder()&#10;        .setNamePattern(Pattern.compile(&quot;ILCE-6400&quot;))&#10;        .build()&#10;&#10;    val pairingRequest: AssociationRequest = AssociationRequest.Builder()&#10;        // Find only devices that match this request filter.&#10;        .addDeviceFilter(deviceFilter)&#10;        // Stop scanning as soon as one device matching the filter is found.&#10;        .setSingleDevice(true)&#10;        .build()&#10;&#10;    val result = CompletableDeferred&lt;IntentSender&gt;()&#10;&#10;    val callback = object : CompanionDeviceManager.Callback() {&#10;        override fun onAssociationPending(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        @Suppress(&quot;OVERRIDE_DEPRECATION&quot;)&#10;        override fun onDeviceFound(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        override fun onAssociationCreated(associationInfo: AssociationInfo) {&#10;&#10;            deviceManager.startObservingDevicePresence(ObservingDevicePresenceRequest.Builder().setAssociationId(associationInfo.id).build())&#10;            // This callback was added in API 33 but the result is also send in the activity result.&#10;            // For handling backwards compatibility we can just have all the logic there instead&#10;        }&#10;&#10;        override fun onFailure(errorMessage: CharSequence?) {&#10;            result.completeExceptionally(IllegalStateException(errorMessage?.toString().orEmpty()))&#10;        }&#10;    }&#10;        val executor = Executor { it.run() }&#10;        deviceManager.associate(pairingRequest, executor, callback)&#10;&#10;    return result.await()&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Copyright 2023 The Android Open Source Project&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10; * you may not use this file except in compliance with the License.&#10; * You may obtain a copy of the License at&#10; *&#10; *     https://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10; * See the License for the specific language governing permissions and&#10; * limitations under the License.&#10; */&#10;&#10;package com.saschl.sonygps.service&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothDevice.TRANSPORT_AUTO&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothGattService&#10;import android.bluetooth.BluetoothManager&#10;import android.bluetooth.BluetoothProfile&#10;import android.bluetooth.le.ScanResult&#10;import android.companion.AssociationInfo&#10;import android.companion.AssociationRequest&#10;import android.companion.BluetoothLeDeviceFilter&#10;import android.companion.CompanionDeviceManager&#10;import android.companion.ObservingDevicePresenceRequest&#10;import android.content.Intent&#10;import android.content.IntentSender&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.IntentSenderRequest&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.annotation.RequiresApi&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.SolidColor&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.getSystemService&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.LifecycleOwner&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.saschl.sonygps.service.CompanionDeviceSampleService.Companion.CHARACTERISTIC_UUID&#10;import com.saschl.sonygps.service.CompanionDeviceSampleService.Companion.SERVICE_UUID&#10;import com.saschl.sonygps.ui.PermissionBox&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.nio.ByteBuffer&#10;import java.time.Instant&#10;import java.time.ZoneId&#10;import java.time.ZonedDateTime&#10;import java.util.concurrent.Executor&#10;import java.util.regex.Pattern&#10;import kotlin.random.Random&#10;&#10;@Composable&#10;fun CompanionDeviceManagerSample() {&#10;    Surface(&#10;        modifier = Modifier.fillMaxSize(),&#10;        color = MaterialTheme.colorScheme.background&#10;    ) {&#10;        val context = LocalContext.current&#10;        val deviceManager = context.getSystemService&lt;CompanionDeviceManager&gt;()&#10;        val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;        var selectedDevice by remember {&#10;            mutableStateOf&lt;BluetoothDevice?&gt;(null)&#10;        }&#10;        if (deviceManager == null || adapter == null) {&#10;            Text(text = &quot;No Companion device manager found. The device does not support it.&quot;)&#10;        } else {&#10;            if (selectedDevice == null) {&#10;                PermissionBox(&#10;                    permissions = listOf(&#10;                        Manifest.permission.BLUETOOTH_CONNECT,&#10;                        Manifest.permission.ACCESS_FINE_LOCATION&#10;                    )&#10;                ) {&#10;&#10;                    DevicesScreen(deviceManager) { device -&gt;&#10;                        selectedDevice =&#10;                            (device.device ?: adapter.getRemoteDevice(device.address))&#10;                    }&#10;                }&#10;            } else {&#10;                PermissionBox(&#10;                    permissions = listOf(&#10;                        Manifest.permission.BLUETOOTH_CONNECT,&#10;                        Manifest.permission.ACCESS_FINE_LOCATION&#10;                    )&#10;                ) {&#10;                    ConnectDeviceScreen(device = selectedDevice!!) {&#10;                        selectedDevice = null&#10;                    }&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;private data class DeviceConnectionState(&#10;    val gatt: BluetoothGatt?,&#10;    val connectionState: Int,&#10;    val mtu: Int,&#10;    val services: List&lt;BluetoothGattService&gt; = emptyList(),&#10;    val messageSent: Boolean = false,&#10;    val messageReceived: String = &quot;&quot;,&#10;) {&#10;    companion object {&#10;        val None = DeviceConnectionState(null, -1, -1)&#10;    }&#10;}&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;private fun BLEConnectEffect(&#10;    device: BluetoothDevice,&#10;    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,&#10;    onStateChange: (DeviceConnectionState) -&gt; Unit,&#10;) {&#10;    val context = LocalContext.current&#10;    val currentOnStateChange by rememberUpdatedState(onStateChange)&#10;&#10;    // Keep the current connection state&#10;    var state by remember {&#10;        mutableStateOf(DeviceConnectionState.None)&#10;    }&#10;&#10;    DisposableEffect(lifecycleOwner, device) {&#10;        // This callback will notify us when things change in the GATT connection so we can update&#10;        // our state&#10;        val callback = object : BluetoothGattCallback() {&#10;            override fun onConnectionStateChange(&#10;                gatt: BluetoothGatt,&#10;                status: Int,&#10;                newState: Int,&#10;            ) {&#10;                super.onConnectionStateChange(gatt, status, newState)&#10;                state = state.copy(gatt = gatt, connectionState = newState)&#10;                currentOnStateChange(state)&#10;&#10;                if (status != BluetoothGatt.GATT_SUCCESS) {&#10;                    // Here you should handle the error returned in status based on the constants&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothGatt#summary&#10;                    // For example for GATT_INSUFFICIENT_ENCRYPTION or&#10;                    // GATT_INSUFFICIENT_AUTHENTICATION you should create a bond.&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createBond()&#10;                    Log.e(&quot;BLEConnectEffect&quot;, &quot;An error happened: $status&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {&#10;                super.onMtuChanged(gatt, mtu, status)&#10;                state = state.copy(gatt = gatt, mtu = mtu)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;                super.onServicesDiscovered(gatt, status)&#10;                state = state.copy(services = gatt.services)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onCharacteristicWrite(&#10;                gatt: BluetoothGatt?,&#10;                characteristic: BluetoothGattCharacteristic?,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicWrite(gatt, characteristic, status)&#10;                state = state.copy(messageSent = status == BluetoothGatt.GATT_SUCCESS)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            @Suppress(&quot;DEPRECATION&quot;, &quot;OVERRIDE_DEPRECATION&quot;)&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, status)&#10;                //   if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;                doOnRead(characteristic.value)&#10;                //    }&#10;            }&#10;&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                value: ByteArray,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, value, status)&#10;                doOnRead(value)&#10;            }&#10;&#10;            private fun doOnRead(value: ByteArray) {&#10;                state = state.copy(messageReceived = value.decodeToString())&#10;                currentOnStateChange(state)&#10;            }&#10;        }&#10;&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_START) {&#10;                if (state.gatt != null) {&#10;                    // If we previously had a GATT connection let's reestablish it&#10;                    state.gatt?.connect()&#10;                } else {&#10;                    // Otherwise create a new GATT connection&#10;                    state = state.copy(&#10;                        gatt = device.connectGatt(&#10;                            context,&#10;                            false,&#10;                            callback,&#10;                            TRANSPORT_AUTO&#10;                        )&#10;                    )&#10;                }&#10;            } else if (event == Lifecycle.Event.ON_STOP) {&#10;                // Unless you have a reason to keep connected while in the bg you should disconnect&#10;                state.gatt?.disconnect()&#10;            }&#10;        }&#10;&#10;        // Add the observer to the lifecycle&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;        // When the effect leaves the Composition, remove the observer and close the connection&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;            state.gatt?.close()&#10;            state = DeviceConnectionState.None&#10;        }&#10;    }&#10;}&#10;&#10;internal fun Int.toConnectionStateString() = when (this) {&#10;    BluetoothProfile.STATE_CONNECTED -&gt; &quot;Connected&quot;&#10;    BluetoothProfile.STATE_CONNECTING -&gt; &quot;Connecting&quot;&#10;    BluetoothProfile.STATE_DISCONNECTED -&gt; &quot;Disconnected&quot;&#10;    BluetoothProfile.STATE_DISCONNECTING -&gt; &quot;Disconnecting&quot;&#10;    else -&gt; &quot;N/A&quot;&#10;}&#10;&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;fun ConnectDeviceScreen(device: BluetoothDevice, onClose: () -&gt; Unit) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Keeps track of the last connection state with the device&#10;    var state by remember(device) {&#10;        mutableStateOf&lt;DeviceConnectionState?&gt;(null)&#10;    }&#10;    // Once the device services are discovered find the GATTServerSample service&#10;    val service by remember(state) {&#10;        mutableStateOf(state?.services?.find { it.uuid == SERVICE_UUID })&#10;    }&#10;    // If the GATTServerSample service is found, get the characteristic&#10;    val characteristic by remember(service) {&#10;        mutableStateOf(service?.getCharacteristic(CHARACTERISTIC_UUID))&#10;    }&#10;&#10;    // This effect will handle the connection and notify when the state changes&#10;    BLEConnectEffect(device = device) {&#10;        // update our state to recompose the UI&#10;        state = it&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        Text(text = &quot;Devices details&quot;, style = MaterialTheme.typography.headlineSmall)&#10;        Text(text = &quot;Name: ${device.name} (${device.address})&quot;)&#10;        Text(text = &quot;Status: ${state?.connectionState?.toConnectionStateString()}&quot;)&#10;        Text(text = &quot;MTU: ${state?.mtu}&quot;)&#10;        Text(text = &quot;Services: ${state?.services?.joinToString { it.uuid.toString() + &quot; &quot; + it.type }}&quot;)&#10;        Text(text = &quot;Message sent: ${state?.messageSent}&quot;)&#10;        Text(text = &quot;Message received: ${state?.messageReceived}&quot;)&#10;        Button(&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    if (state?.connectionState == BluetoothProfile.STATE_DISCONNECTED) {&#10;                        //      state?.gatt?.connect()&#10;                    }&#10;                    // Example on how to request specific MTUs&#10;                    // Note that from Android 14 onwards the system will define a default MTU and&#10;                    // it will only be sent once to the peripheral device&#10;                    state?.gatt?.requestMtu(Random.nextInt(27, 190))&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Request MTU&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    // Once we have the connection discover the peripheral services&#10;                    state?.gatt?.discoverServices()&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Discover&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                /* scope.launch(Dispatchers.IO) {&#10;                     sendData(state?.gatt!!, characteristic!!)&#10;                 }*/&#10;            },&#10;        ) {&#10;            Text(text = &quot;Write to server&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    state?.gatt?.readCharacteristic(characteristic)&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Read characteristic&quot;)&#10;        }&#10;        Button(onClick = onClose) {&#10;            Text(text = &quot;Close&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;fun set_location(latitude: Double, longitude: Double): ByteArray {&#10;    val myLat = (latitude * 1e7).toInt()&#10;    val myLng = (longitude * 1e7).toInt()&#10;    val myLatByte = ByteBuffer.allocate(4).putInt(myLat).array()&#10;    val myLngByte = ByteBuffer.allocate(4).putInt(myLng).array()&#10;    return myLatByte + myLngByte&#10;}&#10;&#10;fun set_date(zoneId: ZoneId): ByteArray {&#10;    val now = ZonedDateTime.ofInstant(Instant.now(), zoneId)&#10;    val year = now.year.toShort()&#10;    val yearBytes = ByteBuffer.allocate(2).putShort(year).array()&#10;    val hour = now.hour&#10;    return byteArrayOf(&#10;        yearBytes[0], yearBytes[1],&#10;        now.monthValue.toByte(),&#10;        now.dayOfMonth.toByte(),&#10;        now.hour.toByte(),&#10;        now.minute.toByte(),&#10;        now.second.toByte()&#10;    )&#10;}&#10;&#10;&#10;@RequiresApi(Build.VERSION_CODES.O)&#10;@Composable&#10;private fun DevicesScreen(&#10;    deviceManager: CompanionDeviceManager,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var associatedDevices by remember {&#10;        // If we already associated the device no need to do it again.&#10;        mutableStateOf(deviceManager.getAssociatedDevices())&#10;    }&#10;&#10;/*    LaunchedEffect(associatedDevices) {&#10;        associatedDevices.forEach {&#10;            //    deviceManager.startObservingDevicePresence(it.address)&#10;        }&#10;&#10;    }*/&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            Text(&#10;                text = &quot;Sony Camera GPS&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(32.dp),&#10;            )&#10;        }) { innerPadding -&gt;&#10;&#10;        Column(modifier = Modifier&#10;            .padding(innerPadding),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            ScanForDevicesMenu(deviceManager) {&#10;                associatedDevices = associatedDevices + it&#10;            }&#10;            AssociatedDevicesList(&#10;                associatedDevices = associatedDevices,&#10;                onConnect = onConnect,&#10;                onDisassociate = {&#10;                    scope.launch {&#10;                        deviceManager.disassociate(it.id)&#10;&#10;                        deviceManager.stopObservingDevicePresence(it.address)&#10;&#10;                        associatedDevices = deviceManager.getAssociatedDevices()&#10;                    }&#10;                },&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ScanForDevicesMenu(&#10;    deviceManager: CompanionDeviceManager,&#10;    onDeviceAssociated: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var errorMessage by remember {&#10;        mutableStateOf(&quot;&quot;)&#10;    }&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartIntentSenderForResult(),&#10;    ) {&#10;        when (it.resultCode) {&#10;            CompanionDeviceManager.RESULT_OK -&gt; {&#10;                it.data?.getAssociationResult()?.run {&#10;                    onDeviceAssociated(this)&#10;                }&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_CANCELED -&gt; {&#10;                errorMessage = &quot;The request was canceled&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_INTERNAL_ERROR -&gt; {&#10;                errorMessage = &quot;Internal error happened&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_DISCOVERY_TIMEOUT -&gt; {&#10;                errorMessage = &quot;No device matching the given filter were found&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_USER_REJECTED -&gt; {&#10;                errorMessage = &quot;The user explicitly declined the request&quot;&#10;            }&#10;&#10;            else -&gt; {&#10;                errorMessage = &quot;Unknown error&quot;&#10;            }&#10;        }&#10;    }&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(MaterialTheme.colorScheme.primaryContainer)&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;    ) {&#10;        Row {&#10;            Text(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f),&#10;                text = &quot;Find &amp; associate another device running the GATTServerSample&quot;,&#10;            )&#10;            Button(&#10;                modifier = Modifier.weight(0.3f),&#10;                onClick = {&#10;                    scope.launch {&#10;                        val intentSender = requestDeviceAssociation(deviceManager)&#10;                        launcher.launch(IntentSenderRequest.Builder(intentSender).build())&#10;                    }&#10;                },&#10;            ) {&#10;                Text(text = &quot;Start&quot;)&#10;            }&#10;        }&#10;        if (errorMessage.isNotBlank()) {&#10;            Text(text = errorMessage, color = MaterialTheme.colorScheme.error)&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;private fun AssociatedDevicesList(&#10;    associatedDevices: List&lt;AssociatedDeviceCompat&gt;,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;    onDisassociate: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        stickyHeader {&#10;            Text(&#10;                text = &quot;Associated Devices:&quot;,&#10;                modifier = Modifier.padding(vertical = 8.dp),&#10;                style = MaterialTheme.typography.titleMedium,&#10;            )&#10;        }&#10;        items(associatedDevices) { device -&gt;&#10;            Row(&#10;                Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically,&#10;            ) {&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(1f),&#10;                ) {&#10;                    Text(text = &quot;ID: ${device.id}&quot;)&#10;                    Text(text = &quot;MAC: ${device.address}&quot;)&#10;                    Text(text = &quot;Name: ${device.name}&quot;)&#10;                }&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(0.6f),&#10;                    horizontalAlignment = Alignment.End,&#10;                    verticalArrangement = Arrangement.Center,&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = { onConnect(device) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                    ) {&#10;                        Text(text = &quot;Connect&quot;)&#10;                    }&#10;                    OutlinedButton(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        onClick = { onDisassociate(device) },&#10;                        border = ButtonDefaults.outlinedButtonBorder().copy(&#10;                            brush = SolidColor(MaterialTheme.colorScheme.error),&#10;                        ),&#10;                    ) {&#10;                        Text(text = &quot;Disassociate&quot;, color = MaterialTheme.colorScheme.error)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun Intent.getAssociationResult(): AssociatedDeviceCompat? {&#10;&#10;        return getParcelableExtra(&#10;            CompanionDeviceManager.EXTRA_ASSOCIATION,&#10;            AssociationInfo::class.java,&#10;        )?.toAssociatedDevice()&#10;&#10;}&#10;&#10;private suspend fun requestDeviceAssociation(deviceManager: CompanionDeviceManager): IntentSender {&#10;    // Match only Bluetooth devices whose service UUID matches this pattern.&#10;    // For this demo we will match our GATTServerSample&#10;    val deviceFilter = BluetoothLeDeviceFilter.Builder()&#10;        .setNamePattern(Pattern.compile(&quot;ILCE-6400&quot;))&#10;        .build()&#10;&#10;    val pairingRequest: AssociationRequest = AssociationRequest.Builder()&#10;        // Find only devices that match this request filter.&#10;        .addDeviceFilter(deviceFilter)&#10;        // Stop scanning as soon as one device matching the filter is found.&#10;        .setSingleDevice(true)&#10;        .build()&#10;&#10;    val result = CompletableDeferred&lt;IntentSender&gt;()&#10;&#10;    val callback = object : CompanionDeviceManager.Callback() {&#10;        override fun onAssociationPending(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        @Suppress(&quot;OVERRIDE_DEPRECATION&quot;)&#10;        override fun onDeviceFound(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        override fun onAssociationCreated(associationInfo: AssociationInfo) {&#10;&#10;            deviceManager.startObservingDevicePresence(ObservingDevicePresenceRequest.Builder().setAssociationId(associationInfo.id).build())&#10;            // This callback was added in API 33 but the result is also send in the activity result.&#10;            // For handling backwards compatibility we can just have all the logic there instead&#10;        }&#10;&#10;        override fun onFailure(errorMessage: CharSequence?) {&#10;            result.completeExceptionally(IllegalStateException(errorMessage?.toString().orEmpty()))&#10;        }&#10;    }&#10;        val executor = Executor { it.run() }&#10;        deviceManager.associate(pairingRequest, executor, callback)&#10;&#10;    return result.await()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/FileTree.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/service/FileTree.kt" />
              <option name="originalContent" value="package com.saschl.sonygps.service&#10;&#10;import android.content.Context&#10;import timber.log.Timber&#10;import com.saschl.sonygps.database.LogRepository&#10;import kotlinx.coroutines.runBlocking&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var logRepository: LogRepository? = null&#10;&#10;        fun initialize(context: Context) {&#10;            if (logRepository == null) {&#10;                    if (logRepository == null) {&#10;                        logRepository = LogRepository(context.applicationContext)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        fun getLogs(): List&lt;String&gt; {&#10;            return logRepository?.let { repo -&gt;&#10;                runBlocking {&#10;                    repo.getRecentLogs().map { logEntry -&gt;&#10;                        &quot;[${priorityToString(logEntry.priority)}] ${logEntry.tag ?: &quot;App&quot;}: ${logEntry.message}&quot; +&#10;                                (logEntry.exception?.let { &quot;\n$it&quot; } ?: &quot;&quot;)&#10;                    }&#10;                }&#10;            } ?: emptyList()&#10;        }&#10;&#10;                        &quot;[${priorityToString(logEntry.priority)}] ${logEntry.tag ?: &quot;App&quot;}: ${logEntry.message}&quot; +&#10;        }&#10;&#10;        private fun priorityToString(priority: Int): String = when (priority) {&#10;            android.util.Log.VERBOSE -&gt; &quot;V&quot;&#10;            android.util.Log.DEBUG -&gt; &quot;D&quot;&#10;            android.util.Log.INFO -&gt; &quot;I&quot;&#10;            android.util.Log.WARN -&gt; &quot;W&quot;&#10;            android.util.Log.ERROR -&gt; &quot;E&quot;&#10;            android.util.Log.ASSERT -&gt; &quot;A&quot;&#10;            else -&gt; priority.toString()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Write a log message to its destination. Called for all level-specific methods by default.&#10;     *&#10;     * @param priority Log level. See [Log] for constants.&#10;     * @param tag Explicit or inferred tag. May be `null`.&#10;     * @param message Formatted log message. May be `null`, but then `t` will not be.&#10;     * @param t Accompanying exceptions. May be `null`, but then `message` will not be.&#10;     */&#10;    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {&#10;        val timestamp = System.currentTimeMillis()&#10;        val exception = t?.stackTraceToString()&#10;&#10;        logRepository.insertLog(timestamp, priority, tag, message, exception)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.saschl.sonygps.service&#10;&#10;import android.content.Context&#10;import timber.log.Timber&#10;import com.saschl.sonygps.database.LogRepository&#10;import kotlinx.coroutines.runBlocking&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;class FileTree(context: Context) : Timber.Tree() {&#10;    private val logRepository = LogRepository(context.applicationContext)&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var logRepository: LogRepository? = null&#10;        private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;, Locale.getDefault())&#10;&#10;        fun initialize(context: Context) {&#10;            if (logRepository == null) {&#10;                synchronized(this) {&#10;                    if (logRepository == null) {&#10;                        logRepository = LogRepository(context.applicationContext)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        fun getLogs(): List&lt;String&gt; {&#10;            return logRepository?.let { repo -&gt;&#10;                runBlocking {&#10;                    repo.getRecentLogs().map { logEntry -&gt;&#10;                        val date = dateFormat.format(Date(logEntry.timestamp))&#10;                        &quot;[$date] [${priorityToString(logEntry.priority)}] ${logEntry.tag ?: &quot;App&quot;}: ${logEntry.message}&quot; +&#10;                                (logEntry.exception?.let { &quot;\n$it&quot; } ?: &quot;&quot;)&#10;                    }&#10;                }&#10;            } ?: emptyList()&#10;        }&#10;&#10;        fun clearLogs() {&#10;            logRepository?.clearAllLogs()&#10;        }&#10;&#10;        private fun priorityToString(priority: Int): String = when (priority) {&#10;            android.util.Log.VERBOSE -&gt; &quot;V&quot;&#10;            android.util.Log.DEBUG -&gt; &quot;D&quot;&#10;            android.util.Log.INFO -&gt; &quot;I&quot;&#10;            android.util.Log.WARN -&gt; &quot;W&quot;&#10;            android.util.Log.ERROR -&gt; &quot;E&quot;&#10;            android.util.Log.ASSERT -&gt; &quot;A&quot;&#10;            else -&gt; priority.toString()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Write a log message to its destination. Called for all level-specific methods by default.&#10;     *&#10;     * @param priority Log level. See [Log] for constants.&#10;     * @param tag Explicit or inferred tag. May be `null`.&#10;     * @param message Formatted log message. May be `null`, but then `t` will not be.&#10;     * @param t Accompanying exceptions. May be `null`, but then `message` will not be.&#10;     */&#10;    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {&#10;        val timestamp = System.currentTimeMillis()&#10;        val exception = t?.stackTraceToString()&#10;&#10;        logRepository.insertLog(timestamp, priority, tag, message, exception)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/ui/ForegroundServiceSampleScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/ui/ForegroundServiceSampleScreen.kt" />
              <option name="originalContent" value="package com.saschl.sonygps.ui&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import com.saschl.sonygps.R&#10;import com.saschl.sonygps.ui.theme.ForegroundService14Theme&#10;&#10;@Composable&#10;internal fun ForegroundServiceSampleScreen(&#10;    serviceRunning: Boolean,&#10;    currentLocation: String?,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    ForegroundService14Theme {&#10;        Surface(&#10;            modifier = Modifier.fillMaxSize(),&#10;            color = MaterialTheme.colorScheme.background&#10;        ) {&#10;            ForegroundServiceSampleScreenContent(&#10;                serviceRunning = serviceRunning,&#10;                currentLocation = currentLocation,&#10;                onClick = onClick,&#10;                modifier = modifier&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ForegroundServiceSampleScreenContent(&#10;    serviceRunning: Boolean,&#10;    currentLocation: String?,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Top,&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(32.dp)&#10;    ) {&#10;        Text(&#10;            text = stringResource(id = R.string.foreground_service_sample_description),&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f)&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f)&#10;            ) {&#10;                ServiceStatusContent(&#10;                    serviceRunning = serviceRunning,&#10;                    onClick = onClick&#10;                )&#10;            }&#10;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f)&#10;            ) {&#10;                LocationUpdate(visible = serviceRunning, location = currentLocation)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ServiceStatusContent(&#10;    serviceRunning: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    ServiceStatusRow(serviceRunning = serviceRunning)&#10;&#10;    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;    Button(onClick = onClick) {&#10;        Text(&#10;            text = stringResource(&#10;                id = if (serviceRunning) {&#10;                    R.string.foreground_service_sample_button_stop&#10;                } else {&#10;                    R.string.foreground_service_sample_button_start&#10;                }&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ServiceStatusRow(&#10;    serviceRunning: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        horizontalArrangement = Arrangement.Center,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        modifier = modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = stringResource(id = R.string.foreground_service_sample_status_title),&#10;            textAlign = TextAlign.Center,&#10;            style = MaterialTheme.typography.titleMedium&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;&#10;        Text(&#10;            text = if (serviceRunning) {&#10;                stringResource(id = R.string.foreground_service_sample_status_running)&#10;            } else {&#10;                stringResource(id = R.string.foreground_service_sample_status_not_running)&#10;            },&#10;            color = if (serviceRunning) {&#10;                Color.Green&#10;            } else {&#10;                Color.Red&#10;            },&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LocationUpdate(&#10;    visible: Boolean,&#10;    location: String?,&#10;) {&#10;    if (visible) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Text(&#10;            text = stringResource(id = R.string.foreground_service_sample_last_location_title),&#10;            style = MaterialTheme.typography.titleMedium&#10;        )&#10;&#10;        Text(&#10;            text = location&#10;                ?: stringResource(id = R.string.foreground_service_sample_last_location_fetching)&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.saschl.sonygps.ui&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import com.saschl.sonygps.R&#10;&#10;@Composable&#10;internal fun ForegroundServiceSampleScreen(&#10;    serviceRunning: Boolean,&#10;    currentLocation: String?,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Surface(&#10;        modifier = Modifier.fillMaxSize(),&#10;        color = MaterialTheme.colorScheme.background&#10;    ) {&#10;        ForegroundServiceSampleScreenContent(&#10;            serviceRunning = serviceRunning,&#10;            currentLocation = currentLocation,&#10;            onClick = onClick,&#10;            modifier = modifier&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ForegroundServiceSampleScreenContent(&#10;    serviceRunning: Boolean,&#10;    currentLocation: String?,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Top,&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(32.dp)&#10;    ) {&#10;        Text(&#10;            text = stringResource(id = R.string.foreground_service_sample_description),&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f)&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f)&#10;            ) {&#10;                ServiceStatusContent(&#10;                    serviceRunning = serviceRunning,&#10;                    onClick = onClick&#10;                )&#10;            }&#10;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f)&#10;            ) {&#10;                LocationUpdate(visible = serviceRunning, location = currentLocation)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ServiceStatusContent(&#10;    serviceRunning: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    ServiceStatusRow(serviceRunning = serviceRunning)&#10;&#10;    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;    Button(onClick = onClick) {&#10;        Text(&#10;            text = stringResource(&#10;                id = if (serviceRunning) {&#10;                    R.string.foreground_service_sample_button_stop&#10;                } else {&#10;                    R.string.foreground_service_sample_button_start&#10;                }&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ServiceStatusRow(&#10;    serviceRunning: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        horizontalArrangement = Arrangement.Center,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        modifier = modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = stringResource(id = R.string.foreground_service_sample_status_title),&#10;            textAlign = TextAlign.Center,&#10;            style = MaterialTheme.typography.titleMedium&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;&#10;        Text(&#10;            text = if (serviceRunning) {&#10;                stringResource(id = R.string.foreground_service_sample_status_running)&#10;            } else {&#10;                stringResource(id = R.string.foreground_service_sample_status_not_running)&#10;            },&#10;            color = if (serviceRunning) {&#10;                Color.Green&#10;            } else {&#10;                Color.Red&#10;            },&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LocationUpdate(&#10;    visible: Boolean,&#10;    location: String?,&#10;) {&#10;    if (visible) {&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Text(&#10;            text = stringResource(id = R.string.foreground_service_sample_last_location_title),&#10;            style = MaterialTheme.typography.titleMedium&#10;        )&#10;&#10;        Text(&#10;            text = location&#10;                ?: stringResource(id = R.string.foreground_service_sample_last_location_fetching)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/sonygps/ui/theme/Theme.kt" />
              <option name="originalContent" value="package com.saschl.sonygps.ui.theme&#10;&#10;import android.app.Activity&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.SideEffect&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.core.view.WindowCompat&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Purple40,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40&#10;&#10;    /* Other default colors to override&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;    */&#10;)&#10;&#10;@Composable&#10;fun ForegroundService14Theme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    // Dynamic color is available on Android 12+&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;    val view = LocalView.current&#10;    if (!view.isInEditMode) {&#10;        SideEffect {&#10;            val window = (view.context as Activity).window&#10;            window.statusBarColor = colorScheme.primary.toArgb()&#10;            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme&#10;        }&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.saschl.sonygps.ui.theme&#10;&#10;import android.app.Activity&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.SideEffect&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.core.view.WindowCompat&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Purple40,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40&#10;&#10;    /* Other default colors to override&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;    */&#10;)&#10;&#10;@Composable&#10;fun ForegroundService14Theme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    // Dynamic color is available on Android 12+&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;    val view = LocalView.current&#10;    if (!view.isInEditMode) {&#10;        SideEffect {&#10;            val window = (view.context as Activity).window&#10;            val insetsController = WindowCompat.getInsetsController(window, view)&#10;            insetsController.isAppearanceLightStatusBars = !darkTheme&#10;        }&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>